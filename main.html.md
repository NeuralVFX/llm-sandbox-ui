# Main


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->

------------------------------------------------------------------------

### get_static

``` python

def get_static(
    fname, icon:bool=False
):

```

*Read static file content from package resources.*

Args: fname: Filename to read from unreal_llm_sandbox/static/.

Returns: String content of the file.

------------------------------------------------------------------------

### interrupt

``` python

def interrupt(
    cell_id:str, request
):

```

*Signal abort for an active stream.*

Args: cell_id: Unique cell identifier.

Returns: “OK” acknowledgment string.

------------------------------------------------------------------------

### exe_prompt

``` python

def exe_prompt(
    cell_id:str, request
):

```

*Execute LLM prompt with notebook context via SSE.*

Args: cell_id: Unique cell identifier. request: FastHTML request with
JSON body containing: - prompt: User’s prompt text. - context: List of
cell dicts for history.

Returns: SSE StreamingResponse yielding LLM chunks.

------------------------------------------------------------------------

### exe_code

``` python

def exe_code(
    cell_id:str, request
):

```

*Execute Python code in Unreal Engine via SSE.*

Args: cell_id: Unique cell identifier. request: FastHTML request with
JSON body containing: - code: Python code string to execute.

Returns: SSE StreamingResponse yielding kernel output messages.

``` python
"""
@rt('/agent_tool_build/{cell_id}', methods=['POST'])
async def agent_stream(cell_id: str, request):
    ""Run agent code generation loop with tool calling via SSE.
    
    Args:
        cell_id: Unique cell identifier.
        request: FastHTML request with JSON body containing:
            - prompt: Code generation request.
            - existing_code: Optional code to modify.
            - context: List of cell dicts for history.
    
    Returns:
        SSE StreamingResponse yielding agent progress (tags, text, outputs).
    ""
    data = await request.json()
    notebook = data.get('notebook', 'untitled')
    stream_key = f"{notebook}:{cell_id}" 

    stream = SSEStream(stream_key)
    def run_chat():
        PROMPT = data['prompt']

        existing_code = data.get('existing_code')
        cell_dict_list = data.get('context', [])  # ← Add this

        # Convert to chat history like prompt cells do
        cells = reconstruct_cells_from_history(cell_dict_list)
        ipynb_list = [cell.to_ipynb() for cell in cells]
        chat_history = prepare_chat_history(ipynb_list)

        if existing_code:
            CODE = existing_code  # Initialize CODE with existing
            PROMPT = f"Modify this code: {existing_code}\n\nRequest: {data['prompt']}"
        else:
            CODE = ""
            PROMPT = data['prompt']
        

        CHAT = lisette.Chat(MODEL, SYS_PROMPT)
        CHAT.hist += chat_history
        CHAT.hist.append( {"role":"assistant", "content":PROMPT})

        a_tools = AgentTools(stream, CHAT, PROMPT,cell_id, code=CODE, print_updates=False)
        tools = a_tools.get_tools()
        
        chat = lisette.Chat(MODEL, SYS_PROMPT, tools=tools)
        chat.hist += chat_history


        gen = chat(PROMPT, max_steps=15)
        for _ in gen:
            if stream.aborted():
                break
        print("Chat loop finished!") 
        time.sleep(0.1) 
        stream.done()
    
    asyncio.create_task(asyncio.to_thread(run_chat))
    return stream.response()
"""
```

    '\n@rt(\'/agent_tool_build/{cell_id}\', methods=[\'POST\'])\nasync def agent_stream(cell_id: str, request):\n    ""Run agent code generation loop with tool calling via SSE.\n\n    Args:\n        cell_id: Unique cell identifier.\n        request: FastHTML request with JSON body containing:\n            - prompt: Code generation request.\n            - existing_code: Optional code to modify.\n            - context: List of cell dicts for history.\n\n    Returns:\n        SSE StreamingResponse yielding agent progress (tags, text, outputs).\n    ""\n    data = await request.json()\n    notebook = data.get(\'notebook\', \'untitled\')\n    stream_key = f"{notebook}:{cell_id}" \n\n    stream = SSEStream(stream_key)\n    def run_chat():\n        PROMPT = data[\'prompt\']\n\n        existing_code = data.get(\'existing_code\')\n        cell_dict_list = data.get(\'context\', [])  # ← Add this\n\n        # Convert to chat history like prompt cells do\n        cells = reconstruct_cells_from_history(cell_dict_list)\n        ipynb_list = [cell.to_ipynb() for cell in cells]\n        chat_history = prepare_chat_history(ipynb_list)\n\n        if existing_code:\n            CODE = existing_code  # Initialize CODE with existing\n            PROMPT = f"Modify this code: {existing_code}\n\nRequest: {data[\'prompt\']}"\n        else:\n            CODE = ""\n            PROMPT = data[\'prompt\']\n\n\n        CHAT = lisette.Chat(MODEL, SYS_PROMPT)\n        CHAT.hist += chat_history\n        CHAT.hist.append( {"role":"assistant", "content":PROMPT})\n\n        a_tools = AgentTools(stream, CHAT, PROMPT,cell_id, code=CODE, print_updates=False)\n        tools = a_tools.get_tools()\n\n        chat = lisette.Chat(MODEL, SYS_PROMPT, tools=tools)\n        chat.hist += chat_history\n\n\n        gen = chat(PROMPT, max_steps=15)\n        for _ in gen:\n            if stream.aborted():\n                break\n        print("Chat loop finished!") \n        time.sleep(0.1) \n        stream.done()\n\n    asyncio.create_task(asyncio.to_thread(run_chat))\n    return stream.response()\n'

------------------------------------------------------------------------

### add_cell

``` python

def add_cell(
    cell_type:str
):

```

*Create and return a new cell of the specified type.*

Args: cell_type: One of ‘markdown’, ‘code’, ‘prompt’, or ‘agent’.

Returns: Rendered FastHTML cell component.

------------------------------------------------------------------------

### Toolbar

``` python

def Toolbar(
    title
):

```

*Build the notebook toolbar with cell creation buttons.*

Args: title: Notebook name to display in the editable input.

Returns: FastHTML Div containing toolbar elements.

------------------------------------------------------------------------

### save_notebook

``` python

def save_notebook(
    notebook_file:str, request
):

```

*Save notebook cells to a Jupyter .ipynb file.*

Args: notebook_file: Filename to save to. request: Request with JSON
body containing ‘cells’ list.

Returns: JSON with status message.

------------------------------------------------------------------------

### load_notebook

``` python

def load_notebook(
    notebook_file:str
):

```

*Load a Jupyter Notebook file and render its cells.*

Args: notebook_file: Path to .ipynb file to load.

Returns: Tuple of Title and Body elements for the page.

------------------------------------------------------------------------

### start_server

``` python

def start_server(
    
):

```
