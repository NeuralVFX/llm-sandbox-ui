[
  {
    "objectID": "notebook_io.html",
    "href": "notebook_io.html",
    "title": "Notebook IO",
    "section": "",
    "text": "reconstruct_cells_from_history\n\ndef reconstruct_cells_from_history(\n    notebook_history\n):\n\nConvert raw JavaScript cell data into rendered cell objects.\nArgs: notebook_history: List of cell dicts from JavaScript with keys: cell_type, cell_id, source, outputs.\nReturns: List of cell objects (MarkdownCell, CodeCell, or PromptCell).\nRaises: ValueError: If cell_type is unknown.\n\n\n\nreconstruct_ipynb_cell\n\ndef reconstruct_ipynb_cell(\n    cell\n):\n\nConvert a Jupyter notebook cell dict to the appropriate cell class.\nArgs: cell: Dict with ‚Äòcell_type‚Äô, ‚Äòmetadata‚Äô, and type-specific keys. Markdown cells may have ‚Äòagent_cell‚Äô or ‚Äòprompt_cell‚Äô in metadata.\nReturns: MarkdownCell, CodeCell, PromptCell, AgentCell, or None if unknown type.\n\n\n\nprepare_chat_history\n\ndef prepare_chat_history(\n    cell_list\n):\n\nConverts a list of notebook cells into a conversation history for the LLM.\nArgs: cell_list (list): List of notebook cells.\nReturns: list: A list of message dictionaries (role/content) for the Chat API.\n\n\n\nis_ask_cell\n\ndef is_ask_cell(\n    cell\n):\n\nCheck if a cell is a prompt cell with a response.\nArgs: cell (dict): The JSON dictionary representing a cell.\nReturns: bool: True if cell contains the prompt/response separator, False otherwise.\n\n\n\nprep_prompt_cell\n\ndef prep_prompt_cell(\n    cell\n):\n\nExtracts text and embedded images from a markdown cell.\nArgs: cell (dict): The JSON dictionary representing a markdown cell.\nReturns: tuple (list): Two lists containing strings (text content) and bytes (decoded image data).\n\n\n\nseperate_markdown\n\ndef seperate_markdown(\n    markdown\n):\n\nSeparate markdown text blocks from embedded base64 images.\nArgs: markdown: List of markdown content strings, potentially containing embedded base64 images in the format (data:image/...;base64,...).\nReturns: List containing strings for text blocks and bytes for decoded images.\n\n\n\nprep_code_cell_output\n\ndef prep_code_cell_output(\n    code_cell, cell_type:str='Code'\n):\n\nExtracts outputs (logs, streams, errors, images) from a code cell.\nArgs: code_cell (dict): The JSON dictionary representing a code cell. cell_type (str, optional): Label for the cell. Defaults to ‚ÄòCode‚Äô.\nReturns: list: A list containing text output, error traces, or image bytes.\n\n\n\nprep_code_cell\n\ndef prep_code_cell(\n    code_cell, cell_type:str='Code'\n):\n\nExtracts and labels source code from a code cell.\nArgs: code_cell (dict): The JSON dictionary representing a code cell. cell_type (str, optional): Label for the cell. Defaults to ‚ÄòCode‚Äô.\nReturns: list: A list containing the labeled header and the source code string.\n\n\n\nformat_for_chat\n\ndef format_for_chat(\n    items\n):\n\nFormats a list of mixed text and image bytes into the OpenAI/LiteLLM message structure.\nArgs: items (list): A list containing strings or byte objects.\nReturns: list: A list of dictionaries with ‚Äòtype‚Äô (text/image_url) keys.\n\n\n\nprep_markdown_cell\n\ndef prep_markdown_cell(\n    markdown_cell\n):\n\nExtracts text and embedded images from a markdown cell.\nArgs: markdown_cell (dict): The JSON dictionary representing a markdown cell.\nReturns: list: A list containing strings (text content) and bytes (decoded image data).",
    "crumbs": [
      "Notebook IO"
    ]
  },
  {
    "objectID": "streaming.html",
    "href": "streaming.html",
    "title": "Streaming",
    "section": "",
    "text": "SSEStream\n\ndef SSEStream(\n    stream_key\n):\n\nUnified SSE streaming with queue-based message passing.\nArgs: cell_id: Unique identifier for abort handling.",
    "crumbs": [
      "Streaming"
    ]
  },
  {
    "objectID": "index.html#features",
    "href": "index.html#features",
    "title": "LLM Sandbox UI",
    "section": "Features",
    "text": "Features\n\nCode Execution - All Code is executed directly in Unreal Engine\nLLM Execution - Ask an LLM for help, with your code/errors in context\nAgentic Tool Use - LLM can use tools directly in Unreal Engine\nUser Tools - Build and register custom agentic tools instantly",
    "crumbs": [
      "LLM Sandbox UI"
    ]
  },
  {
    "objectID": "index.html#syntax-to-register",
    "href": "index.html#syntax-to-register",
    "title": "LLM Sandbox UI",
    "section": "Syntax to Register",
    "text": "Syntax to Register\n\nSimple Tool:\n# Simple tool - no patches needed\n@register_tool\ndef spawn_cube(\n    x: float,  # X world coordinate\n    y: float,  # Y world coordinate\n    z: float   # Z world coordinate\n):\n    \"\"\"Spawn a cube at the specified location.\"\"\"\n    # Your implementation here\n    pass\n\n\nTool with specific Schema overrides:\n# Tool with schema patch - enforces array constraints\nACTOR_PATHS_PATCH = {'type': 'array', 'items': {'type': 'string'}, 'minItems': 1}\n\n@register_tool(patches={'actor_paths': ACTOR_PATHS_PATCH})\ndef delete_actors(\n    actor_paths: List[str]  # List of actor paths to delete\n):\n    \"\"\"Delete the specified actors from the level.\"\"\"\n    # Your implementation here\n    pass\n\n\nEither:\n\nRun this in a Code Cell\nOr create a new python file in your project‚Äôs Content/Python/tools directory #### Tool Discovery:\nTools registered in Code Cells are instantly availible to the LLM\nTools added to Content/Python/tools are discovered on project restart ## To use:\nOpen a Prompt Cell, Click the üõ†Ô∏è icon to activate Unreal tools, and write a prompt!",
    "crumbs": [
      "LLM Sandbox UI"
    ]
  },
  {
    "objectID": "index.html#view-the-tool-schema",
    "href": "index.html#view-the-tool-schema",
    "title": "LLM Sandbox UI",
    "section": "View the tool Schema",
    "text": "View the tool Schema\nSchemas are stored in a global variable TOOL_SCHEMAS, printing it should show something like:\n[{'type': 'function',\n  'function': {'name': 'move_actor_until_hit',\n   'description': '\\n    Drop actors onto surfaces below (or in any direction).\\n ',\n   'parameters': {'type': 'object',\n    'properties': {'actor_paths': {'type': 'array',\n      'description': 'REQUIRED. Non-empty list of Actor UObject paths (strings). Never pass an empty list.',\n      'items': {'type': 'string'},\n      'minItems': 1},\n     'distance': {'type': 'number', 'description': '', 'default': 10000},\n     'buffer_distance': {'type': 'number',\n      'description': '',\n...",
    "crumbs": [
      "LLM Sandbox UI"
    ]
  },
  {
    "objectID": "main.html",
    "href": "main.html",
    "title": "Main",
    "section": "",
    "text": "get_static\n\ndef get_static(\n    fname, icon:bool=False\n):\n\nRead static file content from package resources.\nArgs: fname: Filename to read from unreal_llm_sandbox/static/.\nReturns: String content of the file.\n\n\n\ninterrupt\n\ndef interrupt(\n    cell_id:str, request\n):\n\nSignal abort for an active stream.\nArgs: cell_id: Unique cell identifier.\nReturns: ‚ÄúOK‚Äù acknowledgment string.\n\n\n\nexe_prompt\n\ndef exe_prompt(\n    cell_id:str, request\n):\n\nExecute LLM prompt with notebook context via SSE.\nArgs: cell_id: Unique cell identifier. request: FastHTML request with JSON body containing: - prompt: User‚Äôs prompt text. - context: List of cell dicts for history.\nReturns: SSE StreamingResponse yielding LLM chunks.\n\n\n\nexe_code\n\ndef exe_code(\n    cell_id:str, request\n):\n\nExecute Python code in Unreal Engine via SSE.\nArgs: cell_id: Unique cell identifier. request: FastHTML request with JSON body containing: - code: Python code string to execute.\nReturns: SSE StreamingResponse yielding kernel output messages.\n\n\"\"\"\n@rt('/agent_tool_build/{cell_id}', methods=['POST'])\nasync def agent_stream(cell_id: str, request):\n    \"\"Run agent code generation loop with tool calling via SSE.\n    \n    Args:\n        cell_id: Unique cell identifier.\n        request: FastHTML request with JSON body containing:\n            - prompt: Code generation request.\n            - existing_code: Optional code to modify.\n            - context: List of cell dicts for history.\n    \n    Returns:\n        SSE StreamingResponse yielding agent progress (tags, text, outputs).\n    \"\"\n    data = await request.json()\n    notebook = data.get('notebook', 'untitled')\n    stream_key = f\"{notebook}:{cell_id}\" \n\n    stream = SSEStream(stream_key)\n    def run_chat():\n        PROMPT = data['prompt']\n\n        existing_code = data.get('existing_code')\n        cell_dict_list = data.get('context', [])  # ‚Üê Add this\n\n        # Convert to chat history like prompt cells do\n        cells = reconstruct_cells_from_history(cell_dict_list)\n        ipynb_list = [cell.to_ipynb() for cell in cells]\n        chat_history = prepare_chat_history(ipynb_list)\n\n        if existing_code:\n            CODE = existing_code  # Initialize CODE with existing\n            PROMPT = f\"Modify this code: {existing_code}\\n\\nRequest: {data['prompt']}\"\n        else:\n            CODE = \"\"\n            PROMPT = data['prompt']\n        \n\n        CHAT = lisette.Chat(MODEL, SYS_PROMPT)\n        CHAT.hist += chat_history\n        CHAT.hist.append( {\"role\":\"assistant\", \"content\":PROMPT})\n\n        a_tools = AgentTools(stream, CHAT, PROMPT,cell_id, code=CODE, print_updates=False)\n        tools = a_tools.get_tools()\n        \n        chat = lisette.Chat(MODEL, SYS_PROMPT, tools=tools)\n        chat.hist += chat_history\n\n\n        gen = chat(PROMPT, max_steps=15)\n        for _ in gen:\n            if stream.aborted():\n                break\n        print(\"Chat loop finished!\") \n        time.sleep(0.1) \n        stream.done()\n    \n    asyncio.create_task(asyncio.to_thread(run_chat))\n    return stream.response()\n\"\"\"\n\n'\\n@rt(\\'/agent_tool_build/{cell_id}\\', methods=[\\'POST\\'])\\nasync def agent_stream(cell_id: str, request):\\n    \"\"Run agent code generation loop with tool calling via SSE.\\n\\n    Args:\\n        cell_id: Unique cell identifier.\\n        request: FastHTML request with JSON body containing:\\n            - prompt: Code generation request.\\n            - existing_code: Optional code to modify.\\n            - context: List of cell dicts for history.\\n\\n    Returns:\\n        SSE StreamingResponse yielding agent progress (tags, text, outputs).\\n    \"\"\\n    data = await request.json()\\n    notebook = data.get(\\'notebook\\', \\'untitled\\')\\n    stream_key = f\"{notebook}:{cell_id}\" \\n\\n    stream = SSEStream(stream_key)\\n    def run_chat():\\n        PROMPT = data[\\'prompt\\']\\n\\n        existing_code = data.get(\\'existing_code\\')\\n        cell_dict_list = data.get(\\'context\\', [])  # ‚Üê Add this\\n\\n        # Convert to chat history like prompt cells do\\n        cells = reconstruct_cells_from_history(cell_dict_list)\\n        ipynb_list = [cell.to_ipynb() for cell in cells]\\n        chat_history = prepare_chat_history(ipynb_list)\\n\\n        if existing_code:\\n            CODE = existing_code  # Initialize CODE with existing\\n            PROMPT = f\"Modify this code: {existing_code}\\n\\nRequest: {data[\\'prompt\\']}\"\\n        else:\\n            CODE = \"\"\\n            PROMPT = data[\\'prompt\\']\\n\\n\\n        CHAT = lisette.Chat(MODEL, SYS_PROMPT)\\n        CHAT.hist += chat_history\\n        CHAT.hist.append( {\"role\":\"assistant\", \"content\":PROMPT})\\n\\n        a_tools = AgentTools(stream, CHAT, PROMPT,cell_id, code=CODE, print_updates=False)\\n        tools = a_tools.get_tools()\\n\\n        chat = lisette.Chat(MODEL, SYS_PROMPT, tools=tools)\\n        chat.hist += chat_history\\n\\n\\n        gen = chat(PROMPT, max_steps=15)\\n        for _ in gen:\\n            if stream.aborted():\\n                break\\n        print(\"Chat loop finished!\") \\n        time.sleep(0.1) \\n        stream.done()\\n\\n    asyncio.create_task(asyncio.to_thread(run_chat))\\n    return stream.response()\\n'\n\n\n\n\n\nadd_cell\n\ndef add_cell(\n    cell_type:str\n):\n\nCreate and return a new cell of the specified type.\nArgs: cell_type: One of ‚Äòmarkdown‚Äô, ‚Äòcode‚Äô, ‚Äòprompt‚Äô, or ‚Äòagent‚Äô.\nReturns: Rendered FastHTML cell component.\n\n\n\nToolbar\n\ndef Toolbar(\n    title\n):\n\nBuild the notebook toolbar with cell creation buttons.\nArgs: title: Notebook name to display in the editable input.\nReturns: FastHTML Div containing toolbar elements.\n\n\n\nsave_notebook\n\ndef save_notebook(\n    notebook_file:str, request\n):\n\nSave notebook cells to a Jupyter .ipynb file.\nArgs: notebook_file: Filename to save to. request: Request with JSON body containing ‚Äòcells‚Äô list.\nReturns: JSON with status message.\n\n\n\nload_notebook\n\ndef load_notebook(\n    notebook_file:str\n):\n\nLoad a Jupyter Notebook file and render its cells.\nArgs: notebook_file: Path to .ipynb file to load.\nReturns: Tuple of Title and Body elements for the page.\n\n\n\nstart_server\n\ndef start_server(\n    \n):",
    "crumbs": [
      "Main"
    ]
  },
  {
    "objectID": "llm_tools.html",
    "href": "llm_tools.html",
    "title": "LLM Tools",
    "section": "",
    "text": "read_url\n\ndef read_url(\n    url:str\n):\n\nRetrieve webpage HTML content.\nArgs: url: URL to fetch.\nReturns: Raw HTML string.\n\n\n\nsearch_web\n\ndef search_web(\n    query:str, max_results:int=10\n):\n\nSearch DuckDuckGo and return top results.\nArgs: query: Search string. max_results: Maximum number of results to return.\nReturns: JSON string of results with title, url, snippet.\n\n\n\nregister_tool\n\ndef register_tool(\n    func\n):\n\nRegister a function as a tool.\n\n\n\nget_tools\n\ndef get_tools(\n    \n):\n\nReturn available tool schemas.",
    "crumbs": [
      "LLM Tools"
    ]
  },
  {
    "objectID": "app_config.html",
    "href": "app_config.html",
    "title": "App Config",
    "section": "",
    "text": "Agent Specific Config\n\nAGENT_CODE_SPLIT = '\\n\\n##### Agent Code: &lt;!-- AGENTCODE --&gt;\\n\\n'\nAGENT_CODE_OUTPUT_SPLIT = '\\n\\n##### Code Unit Test Output: &lt;!-- UNITTEST --&gt;\\n\\n'\nAGENT_LLM_OUTPUT_SPLIT = '\\n\\n##### Agent Review: &lt;!-- AGENTREVIEW --&gt;\\n\\n'\n\nUNIT_TEST_STR = \"\"\"Review the results of the UNIT TEST.\\n\nTake into consideration: IS THE TOOL COMPLETING THE ORIGINAL GOAL?\\n\nConsider if anything about the UNIT TEST results shows a possible problem.\\n\nNote if the test doesn't have print statements, or isn't called ei: unit_test().\\n\nMake sure your explanation of any problems is clear.\\n\nThis doesnt have to be scientifically perfect!( If it doesnt follow perfect code convention its ok ). \\n\nIt just has to work, and match the users requirements.\\n\nUltimately you must decide PASS or FAIL.\\n\nExplain thoroughly, but concisely!\\n\n\"\"\"\n\nCODE_GENERATOR = \"\"\"Generate code and a unit test.\\n\nPut the main function and unit test in code.\\n\nThe UNIT TEST, must test the operation of the tool, by running it, and then querying the unreal scene to verify the results.\\n\nThe UNIT TEST must use print(), NEVER USE console.log().\\n\nTHE UNIT TEST FUNCTION MUST BE EXECTUTED ei: unit_test().\\n \nDONT respond with words, only output raw executable CODE.\\n\nDONT use excessive try; excepts or asserts\\n\nDont make Makrdown, Do NOT start with ```python !!\\n\n\"\"\"\n\nCODE_IMPROVER = \"\"\"Improve the code based on feedback.\\n\nInclude the complete corrected code.\\n\nThe UNIT TEST must use print(), NEVER USE console.log().\\n\nTHE UNIT TEST FUNCTION MUST BE EXECTUTED ei: unit_test()\\n\nDONT respond with words, only output raw executable CODE.\\n\nDONT use excessive try; excepts or asserts\\n\nDont make Makrdown, Do NOT start with ```python !! \\n\n\"\"\"\n\nSYS_CODER = \"\"\"You are a python coder, you are writing code for unreal engine 5.6.\\n\nYou review the log of the goal, the previos code and the results of the unit test.\\n\nYou take this into account as yout write new code\\n\n\"\"\"\n\nSYS_REVIEW = \"\"\"You are a code reviewer. Your job is to study the code and answer questions about it.\nWe are working in an unreal engine 5.6 environment\\n\"\"\"\n\nSYS_PROMPT = \"\"\"You are an experiences python developer, with unreal engine 5.6.\\n\nYour job is to either review existing code, or write new code, or improve existing code\\n\n\n--- Use your privded tool ---\nDo any preliminary websearch you need, check help urls\\n\nOur General Code Cycle is: \\n\n- generateCode\\n\n- unitTest   - This executes the code in unreal engine\\n\nwhile unitTest not passed:\n    - improveCode\\n\n    - unitTest\\n\n        - If AN AttributeError: is found in unitTest, do a websearch, check urls\\n\n    - REPEAT!\n\"\"\"",
    "crumbs": [
      "App Config"
    ]
  },
  {
    "objectID": "llm.html",
    "href": "llm.html",
    "title": "LLM",
    "section": "",
    "text": "AgenticToolLoop\n\ndef AgenticToolLoop(\n    model, sys_prompt, local:bool=True, max_iters:int=30\n):\n\nAgentic loop that calls LLM with tools until completion or max iterations.\nManages message history, tool execution, and streaming responses for multi-turn conversations with tool calling capabilities.\nAttributes: model: LiteLLM model identifier string. sys_prompt: System prompt for the conversation. local: If True, use local tools; else call Unreal Engine server. max_iters: Maximum tool call iterations before stopping. tools: List of tool schemas for the LLM. messages: Conversation history. llm_turn_result: Result dict from the last LLM turn.\ndocstring this\n\nü§ñReplyü§ñ\nüß†üß†üß†üß†üß†üß†üß†üß†üß†üß†üß†\nHere‚Äôs the class with docstrings:\nclass AgenticToolLoop():\n    \"\"\"Agentic loop that calls LLM with tools until completion or max iterations.\n    \n    Manages message history, tool execution, and streaming responses for\n    multi-turn conversations with tool calling capabilities.\n    \n    Attributes:\n        model: LiteLLM model identifier string.\n        sys_prompt: System prompt for the conversation.\n        local: If True, use local tools; else call Unreal Engine server.\n        max_iters: Maximum tool call iterations before stopping.\n        tools: List of tool schemas for the LLM.\n        messages: Conversation history.\n        llm_turn_result: Result dict from the last LLM turn.\n    \"\"\"\n\n    def __init__(self, model, sys_prompt, local=True, max_iters=30):\n        \"\"\"Initialize the agentic tool loop.\n        \n        Args:\n            model: LiteLLM model identifier string.\n            sys_prompt: System prompt for the conversation.\n            local: If True, use local tools; else call Unreal Engine server.\n            max_iters: Maximum tool call iterations before stopping.\n        \"\"\"\n        ...\n\n    def get_tools(self, local=True):\n        \"\"\"Fetch available tool schemas.\n        \n        Args:\n            local: If True, return local TOOL_SCHEMAS; else fetch from Unreal.\n            \n        Returns:\n            List of tool schema dicts.\n        \"\"\"\n        ...\n\n    def run_single_tool(self, raw_tool_args, tool_name, local=True):\n        \"\"\"Execute a single tool call.\n        \n        Args:\n            raw_tool_args: JSON string of tool arguments.\n            tool_name: Name of the tool to execute.\n            local: If True, run locally; else POST to Unreal server.\n            \n        Returns:\n            String result from tool execution or error message.\n        \"\"\"\n        ...\n\n    def run_tool_calls(self, tool_calls):\n        \"\"\"Execute a batch of tool calls and update message history.\n        \n        Args:\n            tool_calls: List of dicts with 'tool_id', 'func_name', 'args' keys.\n            \n        Yields:\n            Status strings for each tool execution.\n        \"\"\"\n        ...\n\n    def llm_turn(self):\n        \"\"\"Run one LLM completion turn with streaming.\n        \n        Accumulates text and tool calls from the stream, updates message\n        history, and sets llm_turn_result with finish_reason and tool_calls.\n        \n        Yields:\n            Text content chunks from the LLM response.\n        \"\"\"\n        ...\n\n    def call_llm(self, notebook_history, query):\n        \"\"\"Run the full agentic loop until completion.\n        \n        Args:\n            notebook_history: List of prior conversation messages.\n            query: User's query string.\n            \n        Yields:\n            Text chunks and tool execution status messages.\n        \"\"\"\n        ...",
    "crumbs": [
      "LLM"
    ]
  },
  {
    "objectID": "agent.html",
    "href": "agent.html",
    "title": "Agent",
    "section": "",
    "text": "from dataclasses import dataclass\nimport requests\nfrom ddgs import DDGS\nimport lisette\n\nfrom llm_sandbox_ui.app_config import (\n    KERNEL_URL, MODEL, NOTEBOOK_SYS_PROMPT, SYS_PROMPT,\n    CODE_GENERATOR, CODE_IMPROVER, UNIT_TEST_STR, SYS_CODER, SYS_REVIEW\n)\nfrom llm_sandbox_ui.kernel import *\n\n\n---------------------------------------------------------------------------\nModuleNotFoundError                       Traceback (most recent call last)\nCell In[1], line 6\n      3 from ddgs import DDGS\n      4 import lisette\n----&gt; 6 from llm_sandbox_ui.app_config import (\n      7     KERNEL_URL, MODEL, NOTEBOOK_SYS_PROMPT, SYS_PROMPT,\n      8     CODE_GENERATOR, CODE_IMPROVER, UNIT_TEST_STR, SYS_CODER, SYS_REVIEW\n      9 )\n     10 from llm_sandbox_ui.kernel import *\n\nModuleNotFoundError: No module named 'llm_sandbox_ui'\n\n\n\n\n@dataclass\nclass SentimentChecker:\n    \"\"\" Use this tool register whether you think the code review your looking at approved\\n\n    \"\"\"\n    approved: bool\n\n\nclass AgentTools():\n    def __init__(self, stream, chat, prompt, cell_id, code = '', print_updates = False):\n        \"\"\"Initialize agent tools.\n        \n        Args:\n            stream: SSEStream for output to GUI.\n            chat: LLM chat instance.\n            prompt: User's code generation request.\n            cell_id: Unique cell identifier.\n            code: Existing code to improve.\n            print_updates: Enable debug printing.\n        \"\"\"\n        self.chat = chat\n        self.code = code\n        self.prompt = prompt\n        self.cell_id = cell_id\n        self.print_updates = print_updates\n        self.stream = stream\n\n    def print_update(self, text):\n        \"\"\"Print debug message if updates enabled.\"\"\"\n        if self.print_updates:\n            print(text)\n\n    def collect(self, piece, dtype='text'):\n        \"\"\"Send output to GUI stream.\n        \n        Args:\n            piece: Content to send.\n            dtype: One of 'text', 'tag', or 'output'.\n        \"\"\"\n        if dtype == 'text':\n            self.stream.text(piece)\n        elif dtype == 'tag':\n            self.stream.tag(piece)\n        elif dtype == 'output':\n            self.stream.output(piece)\n\n    def chat_history_swap(self,new_sys,step_prompt):\n        \"\"\"Get LLM response with temporary system prompt.\n        \n        Args:\n            new_sys: Temporary system prompt.\n            step_prompt: Prompt for this step.\n        \n        Returns:\n            Collected response text.\n        \"\"\"\n        old_sys = self.chat.sp\n        self.chat.sp = new_sys\n        old_hist = self.chat.hist[:]\n        \n        response = self.chat(step_prompt,stream=True)\n        collected_stream = self.collect_llm_stream(response)\n        \n        self.chat.sp = old_sys\n        self.chat.hist = old_hist\n        return collected_stream\n\n    def collect_llm_stream(self,response):\n        \"\"\"Stream LLM chunks to GUI.\n        \n        Args:\n            response: LLM streaming response.\n        \n        Returns:\n            Full accumulated text.\n        \"\"\"\n        raw = ''\n        for piece in response:\n            if self.stream.aborted():  \n                break\n            if hasattr(piece, 'choices'):\n                if hasattr(piece.choices[0], 'delta'):\n                    if hasattr(piece.choices[0].delta, 'content'):\n                        crumb = piece.choices[0].delta.content\n                        if crumb:\n                            raw += crumb\n                            self.collect(crumb)\n        return raw\n\n    def search_web(self, query: str, max_results: int = 5):\n        \"\"\"Search DuckDuckGo for query.\n        \n        Args:\n            query: Search string.\n            max_results: Max results to return.\n        \"\"\"\n        from ddgs import DDGS\n        self.print_update('Searching Web\\n')\n        self.collect('tool-websearch',dtype='tag')\n\n        results = DDGS().text(query, max_results=max_results)\n    \n        snippet = str([{\"title\": r[\"title\"], \"url\": r[\"href\"], \"snippet\": r[\"body\"]} \n                for r in results])\n        result = str({'step':'SearchWeb','code':snippet})\n        self.chat.hist.append({\"role\":\"assistant\",\"content\":result})\n        return \n\n\n    def read_url(self, url:str):\n        \"\"\"Fetch webpage content.\n        \n        Args:\n            url: URL to retrieve.\n        \n        Returns:\n            HTML content.\n        \"\"\"\n        import requests\n        self.print_update('Loading URL\\n')\n        self.collect('tool-readurl',dtype='tag')\n\n        response = requests.get(url)\n        html = response.text\n\n        result = str({'step':'ReadUrl','code':html})\n        self.chat.hist.append({\"role\":\"assistant\",\"content\":result})\n        return html\n\n\n    def improve_code(self):\n        \"\"\"Improve existing code based on unit test feedback. Returns improved code.\"\"\"\n        self.print_update('Improving Code\\n')\n        self.collect('code-box',dtype='tag')\n\n        raw_code = self.chat_history_swap(SYS_CODER,CODE_IMPROVER)\n        self.code = raw_code\n\n        result = str({'step':'CodeImprovment','code':self.code})\n        self.chat.hist.append({\"role\":\"user\",\"content\":result})\n\n        return result\n\n\n    def generate_code(self):\n        \"\"\"Generate initial code and unit test for the given prompt. Returns generated code.\"\"\"\n        self.print_update('Generating Code\\n')\n        self.collect('code-box&gt;',dtype='tag')\n\n        raw_code = self.chat_history_swap(SYS_CODER,CODE_GENERATOR)\n        self.code = raw_code\n\n        result = str({'step':'CodeFirstPass','code':self.code})\n        self.chat.hist.append({\"role\":\"user\",\"content\":result})\n        return result\n\n\n    def unit_test(self):\n        \"\"\"Execute code in Unreal Engine and review results. Returns test outcome with pass/fail status.\"\"\"\n        self.print_update('Testing Code\\n')\n        self.collect('unit-box',dtype='tag')\n\n        unit_test_result, unit_test_result_ansi = execute_unreal_code(self.code)\n        \n        # Send to GUi\n        accumulated = convert_to_accumulated(unit_test_result_ansi)\n        self.collect(accumulated, dtype='output')\n\n        unit_test_dict = {'unit_test_result':unit_test_result,\n                          'step':'CodeUnitTest'}\n                          \n        self.chat.hist.append({\"role\":\"assistant\",\n                               \"content\":str(unit_test_dict)})\n\n        self.collect('review-box',dtype='tag')\n        raw_review = self.chat_history_swap(SYS_REVIEW,UNIT_TEST_STR)\n\n        boolean_query =[{\"role\":\"user\", \n                        \"content\":f'Is this response saying this code is good enough to approve?: {raw_review}'}]\n        sent_result = lisette.structured(MODEL,\n                                boolean_query,\n                                tool=SentimentChecker)\n\n        self.print_update(str(sent_result.approved)+'\\n')\n        if sent_result.approved:\n            self.collect(\"DONE\",dtype='tag')\n\n        result = str({'pass':sent_result.approved,\n                    'explanation':raw_review,\n                    'step':'CodeUnitTestReview'}) \n\n        self.chat.hist.append({\"role\":\"assistant\",\"content\":result})\n        return result\n\n    def get_tools(self):\n        return [self.improve_code,self.generate_code,self.unit_test,self.read_url,self.search_web]",
    "crumbs": [
      "Agent"
    ]
  },
  {
    "objectID": "kernel.html",
    "href": "kernel.html",
    "title": "Kernel",
    "section": "",
    "text": "import re\nimport copy\nimport requests\n\nfrom llm_sandbox_ui.app_config import KERNEL_URL\n\n\ndef strip_ansi(text):\n    \"\"\"Remove ANSI escape codes from text.\n    \n    Args:\n        text: String potentially containing ANSI color/formatting codes.\n        \n    Returns:\n        String with all ANSI escape sequences removed.\n    \"\"\"\n    return re.sub(r'\\x1b\\[[0-9;]*m', '', text)\n    \n\ndef format_kernel_stream(json_response, clean_ansi=True ):\n    \"\"\"Format raw kernel response into clean, consolidated messages.\n    \n    Merges consecutive stream messages of the same type and optionally\n    strips ANSI codes from error tracebacks.\n    \n    Args:\n        json_response: Dict with 'messages' key containing kernel output.\n        clean_ansi: If True, remove ANSI codes from tracebacks.\n        \n    Returns:\n        List of formatted message dicts with consolidated streams.\n    \"\"\"    \n    formatted_response = []\n    prev_name = None\n    prev_type = None\n    \n    for msg in json_response.get('messages', []):\n        msg_copy = copy.deepcopy(msg)\n        \n        if msg['msg_type'] == 'error':\n            if clean_ansi:\n                tb = msg_copy['content']['traceback']\n                msg_copy['content']['traceback'] = ['\\n'.join([strip_ansi(line) for line in tb])]\n\n        appended = False\n        if msg['msg_type'] == 'stream':\n            if prev_type == msg['msg_type'] and prev_name == msg['content']['name']:\n                formatted_response[-1]['content']['text'] += msg['content']['text']\n                appended = True\n\n        if not appended:\n            formatted_response.append(msg_copy)\n\n        prev_type = msg['msg_type']\n        if msg['msg_type'] == 'stream':\n            prev_name = msg['content']['name']\n\n    return formatted_response\n\n\ndef execute_unreal_code(code):\n    \"\"\" \n    Execute Python code in the Unreal Engine kernel via ngrok.\n    \n    Args:\n        code (str): Python code to execute in Unreal\n        \n    Returns:\n        list: Formatted kernel messages containing:\n            - 'stream' messages with stdout/stderr output\n            - 'error' messages with exception name, value, and cleaned traceback\n    \"\"\"\n    \n    try:\n        response = requests.post(\n            f'{KERNEL_URL}/execute_sync',\n            json={'code': code},\n            timeout=30\n        )\n        json_response = response.json()\n\n    except (requests.RequestException, requests.Timeout) as e:\n        # Return error in same format as kernel errors\n        error_msg = [{\"msg_type\": \"error\", \"content\": {\"ename\": \"KernelError\", \"evalue\": str(e), \"traceback\": []}}]\n        return error_msg, error_msg\n\n    print (json_response)\n    return format_kernel_stream(json_response), format_kernel_stream(json_response,clean_ansi=False)\n\ndef convert_to_accumulated(json_response):\n    \"\"\"\n    Convert Python kernel response messages to JavaScript accumulated output format.\n    \n    Transforms a list of Jupyter kernel messages into the format expected by the\n    frontend's output rendering system. Merges consecutive stream outputs of the\n    same type (stdout/stderr).\n    \n    Args:\n        json_response: List of dicts with 'msg_type' and 'content' keys from unreal_llm_sandbox.kernel.\n    \n    Returns:\n        List of accumulated output dicts with 'output_type' and type-specific fields.\n    \"\"\"\n    accumulated = []\n    for msg in json_response:\n        t = msg['msg_type']\n        c = msg['content']\n        if t == 'stream':\n            # Check if we can merge with previous\n            if accumulated and accumulated[-1].get('output_type') == 'stream' and accumulated[-1].get('name') == c['name']:\n                accumulated[-1]['text'].append(c['text'])\n            else:\n                accumulated.append({'output_type': 'stream',\n                                    'name': c['name'],\n                                    'text': [c['text']]})\n        elif t == 'execute_result':\n            accumulated.append({'output_type': 'execute_result',\n                                 'data': c['data'],\n                                 'execution_count': c.get('execution_count')})\n        elif t == 'error':\n            accumulated.append({'output_type': 'error', \n                                'ename': c['ename'],\n                                'evalue': c['evalue'],\n                                'traceback': c['traceback']})\n    return accumulated",
    "crumbs": [
      "Kernel"
    ]
  },
  {
    "objectID": "scripts.html",
    "href": "scripts.html",
    "title": "Java Script",
    "section": "",
    "text": "from llm_sandbox_ui.main import get_static\n\nprint(\"=== cells.js ===\")\nprint(get_static('cells.js'))\n\nprint(\"\\n=== styles.css ===\")\nprint(get_static('styles.css'))\n\n=== cells.js ===\n\nconsole.log('CODE_CELL_SCRIPT loaded successfully!');\n\nwindow.cellOutputs = window.cellOutputs || {};\n\n\n/**\n * Toggles the 'minimized' class on a cell element to collapse or expand it.\n * \n * @param {string} cellId - The unique identifier of the cell to toggle.\n */\n function toggleMinimize(cellId){\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    cell.classList.toggle('minimized');\n}\n\n\n/**\n * Retrieves the code content from a Monaco editor instance within a cell.\n * \n * @param {string} cellId - The unique identifier of the cell containing the Monaco editor.\n * @returns {string} The current text content of the Monaco editor model.\n */\n function getMonacoContent(cellId){\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    const monaco_container = cell.querySelector('.monaco-editor');\n    const monaco_editor = monaco_container.querySelector('.monaco-editor');\n    const monaco_model = monaco.editor.getModels().find(\n        m =&gt; m.uri.toString() === monaco_editor.dataset.uri\n    );\n    const monaco_code = monaco_model.getValue();\n    return monaco_code;\n}\n\n\n/**\n * Clears both the output store and output display elements within a cell.\n * \n * @param {string} cellId - The unique identifier of the cell to clear.\n */\nfunction clearOutput(cellId) {\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    const cell_type = cell.getAttribute('data-cell-type');\n\n    // Clear Output Store\n    // For code cells, initialize with empty array\n    if (cell_type == 'code' || cell_type == 'prompt')\n    {\n        const output_store = cell.querySelector('.output-store');    \n        if (cell_type === 'code') {\n            output_store.textContent = \"[]\";\n        }\n        else if (cell_type === 'prompt') {\n            output_store.textContent = \"\";\n        }\n\n        // Clear Output Display\n        const output_display = cell.querySelector('.output-display');\n        output_display.textContent = \"\";\n    }\n\n    else if (cell_type === 'agent') {\n        const output_store_llm = cell.querySelector('.output-store-llm');    \n        const output_store_code = cell.querySelector('.output-store-code');    \n\n        output_store_llm.textContent = \"\";\n        output_store_code.textContent = \"[]\";\n\n        const output_display_llm = cell.querySelector('.output-display-llm');\n        output_display_llm.textContent = \"\";\n        const output_display_code = cell.querySelector('.output-display-code');\n        output_display_code.textContent = \"\";\n\n    }\n}\n\n/**\n * Executes a prompt cell by sending its content to the LLM endpoint and streaming the response.\n * Clears previous output, gathers conversation context from cells above, and renders\n * the streamed response into the cell's output area.\n * \n * @param {string} cellId - The unique identifier of the prompt cell to execute.\n */\nfunction executePromptCell(cellId)\n{\n    // Clear Cell\n    clearOutput(cellId);\n\n    // Get Output Area to Write To\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    const output_store = cell.querySelector('[class=\"output-store\"]');\n\n    // Turn Off Edit Mode\n    const toggle_edit = cell.querySelector('.toggle-edit');\n    toggle_edit.checked = false;\n\n    // Prep Data\n    const chat_history = gatherCellsForLLM(cellId);\n\n    const prompt = extractCellInput(cellId);\n    \n    const notebook_name = document.querySelector('.notebook-name')?.value || 'untitled';\n\n\n    const use_tools = cell.querySelector('.tool-toggle')?.checked ?? true;\n\n    const chat_data = {\n        'prompt': prompt,\n        'context': chat_history,\n        'notebook': notebook_name,\n        'use_tools': use_tools\n     };\n\n    (async () =&gt; {\n    const { fetchEventSource } = await import('https://esm.sh/@microsoft/fetch-event-source@2.0.1');\n    await fetchEventSource(`/execute_prompt/${cellId}`, {\n        method: 'POST',\n        headers: {'Content-Type': 'application/json'},\n        body: JSON.stringify(chat_data),\n        onmessage(ev) {\n            try {\n                const packet = JSON.parse(ev.data);\n                if (packet.type === 'text') {\n                    output_store.textContent += packet.data;\n                }\n            } catch(error) {\n                output_store.textContent += `\n ** Error In Stream ** \n`;\n            }\n        },\n        onerror(error) {\n            output_store.textContent += `\n ** Connection of Server Error ** \n` ;\n            console.error(error);\n        },\n    });\n    })();\n}\n\n\n/**\n * Extracts the input content from a cell based on its type.\n * For code cells, retrieves content from the Monaco editor.\n * For other cell types (note/prompt), retrieves content from the textarea.\n * \n * @param {string} cellId - The unique identifier of the cell to extract input from.\n * @returns {string} The text content of the cell's input area.\n */\nfunction extractCellInput(cellId)\n{\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    const cell_type = cell.getAttribute('data-cell-type');\n    \n    if (cell_type == 'code')\n        {\n            return getMonacoContent(cell.getAttribute('data-cell-id'));\n        }\n    else\n        {\n            const textarea = cell.querySelector(\"textarea\");\n            return textarea.value;\n        }\n}\n\n\n/**\n * Executes a code cell by sending its content to the backend for execution via SSE stream.\n * Clears previous output, retrieves code from the Monaco editor, and streams\n * execution results back to the cell's output area.\n * \n * @param {string} cellId - The unique identifier of the code cell to execute.\n */\nfunction executeCell(cellId)\n{\n    // Clear Output\n    clearOutput(cellId);\n\n    /// Prep Monaco\n    const code = getMonacoContent(cellId);\n\n    const notebook_name = document.querySelector('.notebook-name')?.value || 'untitled';\n\n    const code_data = {\n        'code':code,\n        'notebook': notebook_name \n    };\n\n    // Send Post and Start Stream\n    (async () =&gt; {\n    const { fetchEventSource } = await import('https://esm.sh/@microsoft/fetch-event-source@2.0.1');\n    await fetchEventSource(`/execute_code/${cellId}`, {\n        method: 'POST',\n        headers: {'Content-Type': 'application/json'},\n        body: JSON.stringify(code_data),\n        onmessage(ev) {\n            const packet = JSON.parse(ev.data);\n            if (packet.type === 'output') {\n                accumulateOutput(cellId, packet.data);  // packet.data contains kernel msg\n            }\n        },\n        onerror(err) {\n            console.error('Stream error:', err);\n            throw err; // stops retry\n        }\n    });\n    })();\n}\n\n\n/**\n * Accumulates streamed execution output into a cell's output store.\n * Handles different Jupyter message types (stream, execute_result, display_data, error)\n * and merges consecutive stream outputs of the same name (stdout/stderr) into a single entry.\n * \n * @param {string} cellId - The unique identifier of the cell to accumulate output for.\n * @param {Object} data_dict - The incoming message from the execution stream.\n * @param {string} data_dict.msg_type - Type of message: 'stream', 'execute_result', 'display_data', or 'error'.\n * @param {Object} data_dict.content - The message payload, structure varies by msg_type.\n */\nfunction accumulateOutput(cellId,data_dict)\n{\n        //data_dict = JSON.parse(ev.data);\n\n        // Get cell and output\n        const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n        const output_store = cell.querySelector('.output-store');\n\n        let accumulated_data = [];\n        // Unpack content\n        if (output_store.textContent)\n        {\n            accumulated_data = JSON.parse(output_store.textContent);\n        }\n\n        let acc_len = accumulated_data.length;\n\n        let prev_msg_type = null;\n        // store previous message type\n        if (acc_len &gt; 0)\n        {\n            prev_msg_type = accumulated_data[acc_len-1]['output_type'];\n        }\n\n        if (data_dict['msg_type'] == 'stream')\n        {\n            let added = false;\n            if (prev_msg_type == 'stream')\n            {\n                // Append to the same list if text stream\n                if (accumulated_data[acc_len-1]['name'] == data_dict['content']['name'] )\n                {\n                    accumulated_data[acc_len-1]['text'].push(data_dict['content']['text']);\n                    added = true;\n                }\n\n            }\n            if (!added)\n            {\n            accumulated_data.push( {'output_type':'stream',\n                                'name':data_dict['content']['name'],\n                                'text':[data_dict['content']['text']]});\n\n            }\n\n        }\n        else if (data_dict['msg_type'] == 'execute_result')\n        {\n            accumulated_data.push( {'output_type':'execute_result',\n                                'data':data_dict['content']['data'],\n                                'execution_count':data_dict['content']['execution_count']});\n        }\n        else if (data_dict['msg_type'] == 'display_data')\n        {\n            accumulated_data.push( {'output_type':'display_data',\n                                'data':data_dict['content']['data']});\n        }\n        else if (data_dict['msg_type'] == 'error')\n        {\n            accumulated_data.push( {'output_type':'error',\n                                'ename':data_dict['content']['ename'],\n                                'evalue':data_dict['content']['evalue'],\n                                'traceback':data_dict['content']['traceback']});\n        }\n        output_store.textContent = JSON.stringify(accumulated_data);\n}\n\n\n/**\n * Renders the output of a prompt cell by parsing its stored markdown content\n * and displaying the formatted HTML with syntax highlighting.\n * Retrieves raw markdown from the output store, converts it to HTML using marked.js,\n * and applies Prism.js syntax highlighting to any code blocks.\n * \n * @param {string} cellId - The unique identifier of the prompt cell to render.\n */\nfunction renderOutputPrompt(cellId,tag='')\n{\n    cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    output_store = cell.querySelector('.output-store'+tag);\n    output_display = cell.querySelector('.output-display'+tag);\n    markdown = marked.parse(output_store.textContent);\n    output_display.innerHTML = ''\n    if (markdown)\n    {\n        output_display.innerHTML = markdown;\n        Prism.highlightAllUnder(output_display);\n    }\n}\n\n\n/**\n * Converts a Jupyter-style MIME bundle into renderable HTML.\n * Checks for image formats (PNG, JPEG), HTML, and plain text in priority order,\n * returning the appropriate HTML string for display.\n * \n * @param {Object} data - A MIME bundle object with keys like 'image/png', 'text/html', etc.\n * @returns {string|undefined} HTML string for the highest-priority format found, or undefined if none match.\n */\nfunction renderData(data)\n{\n   if (data.hasOwnProperty(\"image/png\")){\n      return `&lt;img src=\"data:image/png;base64,${data['image/png']}\"&gt;`;\n   }\n   else if (data.hasOwnProperty(\"image/jpeg\")){\n      return `&lt;img src=\"data:image/jpeg;base64,${data['image/jpeg']}\"&gt;`;\n   }\n   else if (data.hasOwnProperty(\"text/html\")){\n      return data['text/html'];\n   }\n   else if (data.hasOwnProperty(\"text/plain\")){\n      return `&lt;div class=\"result-output\"&gt;${data['text/plain']}&lt;/div&gt;`;\n   }\n}\n\n\n/**\n * Renders the accumulated execution output for a code cell by parsing the stored JSON\n * and converting it to displayable HTML. Handles multiple Jupyter output types:\n * - stream: Concatenates text chunks into a single div (stdout/stderr)\n * - execute_result/display_data: Delegates to renderData() for MIME bundle rendering\n * - error: Formats exception name, value, and ANSI-colored traceback\n * \n * Uses AnsiUp to convert ANSI escape codes in tracebacks to styled HTML.\n * \n * @param {string} cellId - The unique identifier of the code cell to render output for.\n */\nfunction renderOutput(cellId, tag='')\n{\n    ansi_up = new AnsiUp();\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    const output_store = cell.querySelector('.output-store'+tag);\n    const output_display = cell.querySelector('.output-display'+tag);\n\n    const data = JSON.parse(output_store.textContent)\n\n    let out_html = ''\n\n    for (i = 0; i &lt; data.length; i++)\n        {\n            if (data[i]['output_type'] == 'stream')\n            {\n                const text_list = data[i]['text'];\n                const text_len = text_list.length;\n\n                out_html += '&lt;div class=\"stream-output\"&gt;';\n                for (s = 0; s &lt; text_len; s++  )\n                    {\n                         out_html += text_list[s];\n                    }\n                out_html += `&lt;/div&gt;`;\n            }\n            else if (data[i]['output_type'] == 'execute_result' || data[i]['output_type'] == 'display_data' )\n            {\n                out_html += renderData(data[i]['data']);\n            }\n            else if (data[i]['output_type'] == 'error')\n            {\n                const trace_list = data[i]['traceback'];\n                const trace_len = trace_list.length;\n\n                // out_html += `&lt;div class=\"error-name\"&gt;${data[i].ename}: ${data[i].evalue}&lt;/div&gt;`;\n                out_html += '&lt;pre class=\"traceback\"&gt;';\n                for (s = 0; s &lt; trace_len; s++  )\n                    {\n                         out_html += ansi_up.ansi_to_html(trace_list[s]);\n                         out_html += `\n`;\n                    }\n                out_html += '&lt;/pre&gt;';\n\n            }\n\n        }\n    output_display.innerHTML = out_html; \n}\n\n\n/**\n * Removes a cell element from the DOM by its unique identifier.\n * \n * @param {string} cellId - The unique identifier of the cell to delete.\n */\n function deleteCell(cellId) {\n    document.querySelector(`[data-cell-id=\"${cellId}\"]`).remove();\n}\n\n\n/**\n * Moves a cell down by swapping its position with its next sibling element.\n * If no next sibling exists, the cell remains in place.\n * \n * @param {string} cellId - The unique identifier of the cell to move down.\n */\n function moveDown(cellId){\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    // Check Sibling\n    const sibling = cell.nextElementSibling;\n    if (sibling){\n        cell.parentNode.insertBefore(sibling,cell);\n    }\n}\n\n\n/**\n * Moves a cell up by swapping its position with its previous sibling element.\n * If no previous sibling exists, the cell remains in place.\n * \n * @param {string} cellId - The unique identifier of the cell to move up.\n */\nfunction moveUp(cellId){\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    \n    // Check Sibling\n    const sibling = cell.previousElementSibling;\n    if (sibling){\n        cell.parentNode.insertBefore(cell,sibling);\n    }\n}\n\n\n/**\n * Gathers all cells above a given cell and formats them for LLM context.\n * Collects each cell's id, type, source content, and outputs until reaching the target cell.\n * \n * @param {string} cellId - The unique identifier of the cell to stop at (exclusive).\n * @returns {Array&lt;Object&gt;} Array of cell objects with cell_id, cell_type, source, and outputs.\n */\nfunction gatherCellsForLLM(cellId){\n    let cell_out_list = [];\n    const cells = document.querySelectorAll('[data-cell-id]');\n    for (let i = 0; i &lt; cells.length; i++){\n\n        const cell = cells[i];\n        const id = cell.getAttribute('data-cell-id');\n        const type = cell.getAttribute('data-cell-type');\n        const input = extractCellInput(id);\n        const output = extractCellOutput(id);\n\n        if (cellId == id)\n        {\n            break;\n        }\n    \n        const cell_dict = {'cell_id':id,\n                    'cell_type':type,\n                    'source':input,\n                    'outputs':output,\n                    };\n        cell_out_list.push(cell_dict);\n    }\n    return cell_out_list;\n}\n\n\n/**\n * Extracts the output content from a cell based on its type.\n * For code cells, parses JSON from the output store.\n * For prompt cells, returns the raw text content.\n * \n * @param {string} cellId - The unique identifier of the cell.\n * @returns {Array|string|null} Parsed output array for code cells, string for prompt cells, null otherwise.\n */\nfunction extractCellOutput(cellId){\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    const cell_type = cell.getAttribute('data-cell-type');\n    const output_store = cell.querySelector('.output-store');\n    \n    if (cell_type == 'code')\n        {\n            try{\n                return JSON.parse(output_store.textContent);\n            }catch{\n                return [];\n            }\n        }\n    else if (cell_type == 'prompt')\n        {\n            return output_store.textContent;\n        }\n    else if (cell_type == 'agent')\n    {\n        return getMonacoContent(cellId);\n    }\n        \n    else{\n        return null;\n    }\n}\n\n\n/**\n * Sets up a MutationObserver to watch a cell's output store for changes\n * and automatically re-renders the output when changes are detected.\n * Handles both code cells (renderOutput) and prompt cells (renderPromptOutput).\n * \n * @param {string} cellId - The unique identifier of the cell to watch.\n */\nfunction watchOutputStore(cellId) {\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    const cell_type = cell.getAttribute('data-cell-type');\n\n    // Throttle render to ~15fps\n    let renderPending = false;\n    function throttledRender(fn) {\n        if (renderPending) return;\n        renderPending = true;\n        setTimeout(() =&gt; {\n            fn();\n            renderPending = false;\n        }, 30);\n    }\n\n    const config = { characterData: true, childList: true, subtree: true };\n\n    // Initial render\n    if (cell_type == 'code') {\n        renderOutput(cellId);\n    } else if (cell_type == 'prompt') {\n        renderOutputPrompt(cellId);\n    } else if (cell_type == 'agent') {\n        renderOutputPrompt(cellId, '-llm');\n        renderOutput(cellId, '-code');\n    }\n\n    // Set up observers\n    if (cell_type == 'code') {\n        const output_store = cell.querySelector('.output-store');\n        new MutationObserver(() =&gt; throttledRender(() =&gt; renderOutput(cellId)))\n            .observe(output_store, config);\n    } else if (cell_type == 'prompt') {\n        const output_store = cell.querySelector('.output-store');\n        new MutationObserver(() =&gt; throttledRender(() =&gt; renderOutputPrompt(cellId)))\n            .observe(output_store, config);\n    } else if (cell_type == 'agent') {\n        const output_store_llm = cell.querySelector('.output-store-llm');\n        const output_store_code = cell.querySelector('.output-store-code');\n        new MutationObserver(() =&gt; throttledRender(() =&gt; renderOutput(cellId, '-code')))\n            .observe(output_store_code, config);\n        new MutationObserver(() =&gt; throttledRender(() =&gt; renderOutputPrompt(cellId, '-llm')))\n            .observe(output_store_llm, config);\n    }\n}\n\nasync function saveNotebook(filename) {\n    const cells = gatherCellsForLLM(null);  // null = gather all cells\n    await fetch(`/save_notebook/${filename}`, {\n        method: 'POST',\n        headers: {'Content-Type': 'application/json'},\n        body: JSON.stringify({cells: cells})\n    });\n    console.log('Notebook saved!');\n}\n\nsetInterval(() =&gt; {\n    const notebookName = document.querySelector('.notebook-name')?.value || 'untitled';\n    saveNotebook(notebookName+'.ipynb');\n}, 2000);\n\n\n\n\n/**\n * Retrieves the code content from a Monaco editor instance within a cell.\n * \n * @param {string} cellId - The unique identifier of the cell containing the Monaco editor.\n * @returns {string} The current text content of the Monaco editor model.\n */\nfunction setMonacoContent(cellId, txt) {\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    const monaco_container = cell.querySelector('.monaco-editor');\n\n    // 1. Get the URI (ensure you grab it from the correct element in your DOM)\n    const uri = monaco_container.dataset.uri || \n                monaco_container.querySelector('[data-uri]')?.dataset.uri;\n\n    const monaco_model = monaco.editor.getModels().find(\n        m =&gt; m.uri.toString() === uri\n    );\n\n    if (monaco_model) {\n        monaco_model.setValue(txt);\n\n        // 2. Find the editor instance attached to this model\n        const editorInstance = monaco.editor.getEditors().find(\n            e =&gt; e.getModel() === monaco_model\n        );\n\n        // 3. Use the REAL method to scroll to the last line\n        if (editorInstance) {\n            editorInstance.revealLine(monaco_model.getLineCount());\n        }\n    }\n}\n\n\n/**\n * Executes a prompt cell by sending its content to the LLM endpoint and streaming the response.\n * Clears previous output, gathers conversation context from cells above, and renders\n * the streamed response into the cell's output area.\n * \n * @param {string} cellId - The unique identifier of the prompt cell to execute.\n */\nfunction executeAgentCell(cellId)\n{\n    // Clear Cell\n    clearOutput(cellId);\n\n\n    const error_text = `\n ** Error In Stream ** \n` ;\n    // Get Output Area to Write To\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    const output_store_llm = cell.querySelector('[class=\"output-store-llm\"]');\n    const output_store_code = cell.querySelector('[class=\"output-store-code\"]');\n    const status_div = cell.querySelector('#status');\n    const iteration_div = cell.querySelector('#iteration');\n    const output_display_llm = cell.querySelector('.output-display-llm');\n    const output_display_code = cell.querySelector('.output-display-code');\n\n\n    // Turn Off Edit Mode\n    const toggle_edit = cell.querySelector('.toggle-edit');\n    toggle_edit.checked = false;\n\n    // Prep Data\n\n    const prompt = extractCellInput(cellId);\n    const existingCode = getMonacoContent(cellId);\n    const hasCode = existingCode && existingCode.trim().length &gt; 0;\n\n    const chat_history = gatherCellsForLLM(cellId);\n\n    const notebook_name = document.querySelector('.notebook-name')?.value || 'untitled';\n\n    const chat_data = {\n        'prompt': prompt,\n        'existing_code': hasCode ? existingCode : null,\n        'context': chat_history  ,\n        'notebook': notebook_name \n    };\n    \n    setMonacoContent(cellId,'')\n\n    let tag;\n    let iter = 0;\n    (async () =&gt; {\n    const { fetchEventSource } = await import('https://esm.sh/@microsoft/fetch-event-source@2.0.1');\n    await fetchEventSource(`/agent_tool_build/${cellId}`, {\n        method: 'POST',\n        headers: {'Content-Type': 'application/json'},\n        body: JSON.stringify(chat_data),\n        onclose() {\n        throw new Error('Stream closed');  // Prevents retry\n        },\n        onmessage(ev) {\n\n\n            // Try to recieve packet\n            try{\n\n                const packet = JSON.parse(ev.data)\n                const { type, data } = packet;\n\n                //////////////////////\n                // Set GUI Tags / Labels\n                //////////////////////\n                if (type == 'tag')\n                {\n                    if ( data.includes('review-box'))\n                    {\n                        status_div.textContent = 'Reviewing Unit Test';\n                        tag = 'llm';\n                        output_store_llm.textContent = ''\n                    }\n                    if (data.includes('code-box' ))\n                    {\n                        iter += 1\n                        iteration_div.textContent = 'Iteration: '+iter.toString();\n                        \n                        status_div.classList.remove('complete');\n                        status_div.classList.add('running');\n                        status_div.textContent = 'Writing Code';\n\n                        // When finished successfully\n\n                        tag = 'code';\n                        setMonacoContent(cellId,'')\n\n                    }\n                    if (data.includes('unit-box' ))\n                    {\n                        status_div.textContent = 'Exectuting Unit Test';\n                        tag = 'unit';\n                  \n                    }\n                    if (data.includes( 'DONE')) \n                    {\n                        status_div.classList.remove('running');\n                        status_div.classList.add('complete');\n                        status_div.textContent = 'Code Approved!';\n                        throw new Error('Stream complete');  // Stops retry\n                    }\n                    if (data.includes( 'tool-websearch')) \n                    {\n                        status_div.classList.remove('complete');\n                        status_div.classList.add('running');\n                        status_div.textContent = 'Searching Web';\n\n                    }\n                    if (data.includes( 'tool-readurl')) \n                    {\n                        status_div.textContent = 'Checking Website';\n\n                    }\n                }\n                ///////////////////////\n                //  Accumulate Stream\n                ///////////////////////\n                else if( type == 'text')\n                {\n                    // accumulate stream\n                    if  (tag == 'llm')\n                    {\n                        output_store_llm.textContent += data ;\n                        output_display_llm.scrollTop = output_display_llm.scrollHeight;\n                    }\n                    else if  (tag == 'code')\n                    {\n                        const code = getMonacoContent(cellId);\n                        setMonacoContent(cellId,code+data);\n                    }\n\n                }\n                else if(type == 'output')\n                {\n                        // Unit doesnt stream atm so we replace\n                        output_store_code.textContent = JSON.stringify(data);\n                        requestAnimationFrame(() =&gt; {\n                            output_display_code.scrollTop = output_display_code.scrollHeight;\n                        });\n                }\n\n            }\n            // Print error \n            catch(error){\n                if (error.message === 'Stream complete') throw error; \n\n                if  (tag == 'llm')\n                {\n                    output_store_llm.textContent += error_text ;\n                }\n                else if  (tag == 'code')\n                {\n                    const code = getMonacoContent(cellId);\n                    setMonacoContent(cellId,code+error_text);\n                }\n                else if  (tag == 'unit')\n                {\n                    // Unit doesnt stream atm so we replace\n                    output_store_code.textContent = JSON.stringify([{\n                        output_type: 'error',\n                        ename: 'StreamError',\n                        evalue: 'Error in stream',\n                        traceback: [error_text]\n                    }]);\n                }\n            }\n        },\n        onerror(error) {\n\n            throw error;  // Throwing from onerror stops retry\n\n        },\n    });\n    })();\n}\n\ndocument.addEventListener('DOMContentLoaded', () =&gt; {\n    // Adjust all textareas on load + input\n    document.querySelectorAll('textarea[class*=\"content-edit\"]').forEach(textarea =&gt; {\n        textarea.style.height = 'auto';\n        textarea.style.height = Math.min(textarea.scrollHeight, 500) + 'px';\n        \n        textarea.addEventListener('input', () =&gt; {\n            textarea.style.height = 'auto';\n            textarea.style.height = Math.min(textarea.scrollHeight, 500) + 'px';\n        });\n    });\n\n    // Adjust when toggling to edit mode\n    document.querySelectorAll('.toggle-edit').forEach(checkbox =&gt; {  // Changed selector\n        checkbox.addEventListener('change', () =&gt; {\n            if (checkbox.checked) {\n                const cell = checkbox.closest('[data-cell-id]');  // Changed - find parent cell\n                const textarea = cell?.querySelector('textarea.content-edit');  // Changed\n                if (textarea) {\n                    textarea.style.height = 'auto';\n                    textarea.style.height = Math.min(textarea.scrollHeight, 500) + 'px';\n                }\n            }\n        });\n    });\n});\n\nlet currentFocusedCellId = null;\n\ndocument.addEventListener('click', (e) =&gt; {\n    const cell = e.target.closest('[data-cell-id]');  // Changed from [type=\"cell\"]\n    \n    // Remove outline from all cells\n    document.querySelectorAll('[data-cell-id]').forEach(c =&gt; {  // Changed\n        c.style.outline = 'none';\n    });\n    \n    // Add outline to clicked cell\n    if (cell) {\n        cell.style.outline = '2px solid #3b82f6';\n        cell.style.outlineOffset = '-8px';\n        cell.style.borderRadius = '16px';\n        currentFocusedCellId = cell.dataset.cellId;  // Changed from cell.id\n    }\n    document.querySelectorAll('.toggle-edit').forEach(t =&gt; {  // Changed selector\n        const tCell = t.closest('[data-cell-id]');\n        if (tCell && tCell.dataset.cellId !== cell?.dataset.cellId) {\n            t.checked = false;\n        }\n    });\n    const isContentArea = e.target.closest('.markdown-body') || \n                        e.target.closest('textarea[class*=\"content-edit\"]');\n\n    if (isContentArea && cell) {\n        const toggleCheckbox = cell.querySelector('.toggle-edit');  // Changed - find within cell\n        if (toggleCheckbox) {\n            toggleCheckbox.checked = true;\n            toggleCheckbox.dispatchEvent(new Event('change'));\n        }\n    }\n});\n\n\n=== styles.css ===\n\n.markdown-body { \n    background-color: bg-gray-900 !important; \n}\n.markdown-body ul { \n    list-style-type: disc !important; \n    padding-left: 2em !important; \n}\n.markdown-body ol { \n    list-style-type: decimal !important; \n    padding-left: 2em !important; \n}\n[data-cell-id].minimized .output-display-llm,\n[data-cell-id].minimized .output-display-code {\n    display: none !important;\n}\n[data-cell-id].minimized .content-edit,\n[data-cell-id].minimized .content-render,\n[data-cell-id].minimized .output-display,\n[data-cell-id].minimized .text-gray-400 {\n    display: none;\n}\n[data-cell-id].minimized .content-edit,\n[data-cell-id].minimized .content-render {\n    display: none !important;\n}\n[data-cell-id].minimized .monaco-editor,\n[data-cell-id].minimized .content-edit,\n[data-cell-id].minimized .content-render,\n[data-cell-id].minimized .output-display {\n    max-height: 0 !important;\n    overflow: hidden;\n}\n[data-cell-id].minimized .bg-gray-800 {\n    opacity: 0.5 !important;\n}\nbody {\n    background-color: #070707 !important;  /* 95% black = 5% brightness */\n}\n.markdown-body { \n    background-color: bg-gray-900 !important;\n    font-size: 0.825rem !important;  /* ‚Üê Smaller base size */\n}\n.markdown-body h1 { font-size: 1.25rem !important; }\n.markdown-body h2 { font-size: 1.1rem !important; }\n.markdown-body h3 { font-size: 1.0rem !important; }\n.markdown-body ul, .markdown-body ol { \n    list-style-type: disc !important; \n    padding-left: 2em !important;\n    font-size: 0.825rem !important;  /* ‚Üê Match body */\n}\n.content-edit {\n    font-size: 0.825rem !important;  /* ‚Üê Textarea size */\n}\n\n.content-render {\n    background-color: #1a1a1a  !important;  /* ‚Üê Medium grey for rendered input */\n}\n.running { color: #ef4444 !important; }\n.complete { color: #22c55e !important; }\n#notebook-container {\n    height: calc(100vh - 64px); \n    overflow-y: auto;\n.toggle-edit:checked ~ .content-edit { display: block; }\n.toggle-edit:checked ~ .content-render { display: none; }\n.toggle-edit:not(:checked) ~ .content-edit { display: none; }\n.toggle-edit:not(:checked) ~ .content-render { display: block;}\nlabel:has(.tool-toggle:not(:checked)) {\n\n    opacity: 0.3;\n\n}\n\n\n\n\nJAVASCRIPT = \"\"\"\nconsole.log('CODE_CELL_SCRIPT loaded successfully!');\n\nwindow.cellOutputs = window.cellOutputs || {};\n\n\n/**\n * Toggles the 'minimized' class on a cell element to collapse or expand it.\n * \n * @param {string} cellId - The unique identifier of the cell to toggle.\n */\n function toggleMinimize(cellId){\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    cell.classList.toggle('minimized');\n}\n\n\n/**\n * Retrieves the code content from a Monaco editor instance within a cell.\n * \n * @param {string} cellId - The unique identifier of the cell containing the Monaco editor.\n * @returns {string} The current text content of the Monaco editor model.\n */\n function getMonacoContent(cellId){\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    const monaco_container = cell.querySelector('.monaco-editor');\n    const monaco_editor = monaco_container.querySelector('.monaco-editor');\n    const monaco_model = monaco.editor.getModels().find(\n        m =&gt; m.uri.toString() === monaco_editor.dataset.uri\n    );\n    const monaco_code = monaco_model.getValue();\n    return monaco_code;\n}\n\n\n/**\n * Clears both the output store and output display elements within a cell.\n * \n * @param {string} cellId - The unique identifier of the cell to clear.\n */\nfunction clearOutput(cellId) {\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    const cell_type = cell.getAttribute('data-cell-type');\n\n    // Clear Output Store\n    // For code cells, initialize with empty array\n    if (cell_type == 'code' || cell_type == 'prompt')\n    {\n        const output_store = cell.querySelector('.output-store');    \n        if (cell_type === 'code') {\n            output_store.textContent = \"[]\";\n        }\n        else if (cell_type === 'prompt') {\n            output_store.textContent = \"\";\n        }\n\n        // Clear Output Display\n        const output_display = cell.querySelector('.output-display');\n        output_display.textContent = \"\";\n    }\n\n    else if (cell_type === 'agent') {\n        const output_store_llm = cell.querySelector('.output-store-llm');    \n        const output_store_code = cell.querySelector('.output-store-code');    \n\n        output_store_llm.textContent = \"\";\n        output_store_code.textContent = \"[]\";\n\n        const output_display_llm = cell.querySelector('.output-display-llm');\n        output_display_llm.textContent = \"\";\n        const output_display_code = cell.querySelector('.output-display-code');\n        output_display_code.textContent = \"\";\n\n    }\n}\n\n/**\n * Executes a prompt cell by sending its content to the LLM endpoint and streaming the response.\n * Clears previous output, gathers conversation context from cells above, and renders\n * the streamed response into the cell's output area.\n * \n * @param {string} cellId - The unique identifier of the prompt cell to execute.\n */\nfunction executePromptCell(cellId)\n{\n    clearOutput(cellId);\n\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    const output_store = cell.querySelector('[class=\"output-store\"]');\n    \n    const spinner = cell.querySelector('.cell-spinner');\n    spinner?.classList.remove('hidden');\n\n    const toggle_edit = cell.querySelector('.toggle-edit');\n    toggle_edit.checked = false;\n\n    const chat_history = gatherCellsForLLM(cellId);\n    const prompt = extractCellInput(cellId);\n    const notebook_name = document.querySelector('.notebook-name')?.value || 'untitled';\n    const use_tools = cell.querySelector('.tool-toggle')?.checked ?? true;\n\n    const chat_data = {\n        'prompt': prompt,\n        'context': chat_history,\n        'notebook': notebook_name,\n        'use_tools': use_tools\n    };\n\n    (async () =&gt; {\n        const { fetchEventSource } = await import('https://esm.sh/@microsoft/fetch-event-source@2.0.1');\n        await fetchEventSource(`/execute_prompt/${cellId}`, {\n            method: 'POST',\n            headers: {'Content-Type': 'application/json'},\n            body: JSON.stringify(chat_data),\n            onmessage(ev) {\n                try {\n                    const packet = JSON.parse(ev.data);\n                    if (packet.type === 'text') {\n                        output_store.textContent += packet.data;\n                    }\n                } catch(error) {\n                    output_store.textContent += ` ** Error In Stream ** `;\n                }\n            },\n            onerror(error) {\n                output_store.textContent += ` ** Connection or Server Error ** `;\n                spinner?.classList.add('hidden');\n                console.error(error);\n                throw error;  // This stops fetchEventSource from retrying\n            },\n        });\n        spinner?.classList.add('hidden');\n    })();\n}\n\n/**\n * Extracts the input content from a cell based on its type.\n * For code cells, retrieves content from the Monaco editor.\n * For other cell types (note/prompt), retrieves content from the textarea.\n * \n * @param {string} cellId - The unique identifier of the cell to extract input from.\n * @returns {string} The text content of the cell's input area.\n */\nfunction extractCellInput(cellId)\n{\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    const cell_type = cell.getAttribute('data-cell-type');\n    \n    if (cell_type == 'code')\n        {\n            return getMonacoContent(cell.getAttribute('data-cell-id'));\n        }\n    else\n        {\n            const textarea = cell.querySelector(\"textarea\");\n            return textarea.value;\n        }\n}\n\n\n/**\n * Executes a code cell by sending its content to the backend for execution via SSE stream.\n * Clears previous output, retrieves code from the Monaco editor, and streams\n * execution results back to the cell's output area.\n * \n * @param {string} cellId - The unique identifier of the code cell to execute.\n */\nfunction executeCell(cellId)\n{\n    // Clear Output\n    clearOutput(cellId);\n\n    /// Prep Monaco\n    const code = getMonacoContent(cellId);\n\n    const notebook_name = document.querySelector('.notebook-name')?.value || 'untitled';\n\n    const code_data = {\n        'code':code,\n        'notebook': notebook_name \n    };\n\n    // Send Post and Start Stream\n    (async () =&gt; {\n    const { fetchEventSource } = await import('https://esm.sh/@microsoft/fetch-event-source@2.0.1');\n    await fetchEventSource(`/execute_code/${cellId}`, {\n        method: 'POST',\n        headers: {'Content-Type': 'application/json'},\n        body: JSON.stringify(code_data),\n        onmessage(ev) {\n            const packet = JSON.parse(ev.data);\n            if (packet.type === 'output') {\n                accumulateOutput(cellId, packet.data);  // packet.data contains kernel msg\n            }\n        },\n        onerror(err) {\n            console.error('Stream error:', err);\n            throw err; // stops retry\n        }\n    });\n    })();\n}\n\n\n/**\n * Accumulates streamed execution output into a cell's output store.\n * Handles different Jupyter message types (stream, execute_result, display_data, error)\n * and merges consecutive stream outputs of the same name (stdout/stderr) into a single entry.\n * \n * @param {string} cellId - The unique identifier of the cell to accumulate output for.\n * @param {Object} data_dict - The incoming message from the execution stream.\n * @param {string} data_dict.msg_type - Type of message: 'stream', 'execute_result', 'display_data', or 'error'.\n * @param {Object} data_dict.content - The message payload, structure varies by msg_type.\n */\nfunction accumulateOutput(cellId,data_dict)\n{\n        //data_dict = JSON.parse(ev.data);\n\n        // Get cell and output\n        const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n        const output_store = cell.querySelector('.output-store');\n\n        let accumulated_data = [];\n        // Unpack content\n        if (output_store.textContent)\n        {\n            accumulated_data = JSON.parse(output_store.textContent);\n        }\n\n        let acc_len = accumulated_data.length;\n\n        let prev_msg_type = null;\n        // store previous message type\n        if (acc_len &gt; 0)\n        {\n            prev_msg_type = accumulated_data[acc_len-1]['output_type'];\n        }\n\n        if (data_dict['msg_type'] == 'stream')\n        {\n            let added = false;\n            if (prev_msg_type == 'stream')\n            {\n                // Append to the same list if text stream\n                if (accumulated_data[acc_len-1]['name'] == data_dict['content']['name'] )\n                {\n                    accumulated_data[acc_len-1]['text'].push(data_dict['content']['text']);\n                    added = true;\n                }\n\n            }\n            if (!added)\n            {\n            accumulated_data.push( {'output_type':'stream',\n                                'name':data_dict['content']['name'],\n                                'text':[data_dict['content']['text']]});\n\n            }\n\n        }\n        else if (data_dict['msg_type'] == 'execute_result')\n        {\n            accumulated_data.push( {'output_type':'execute_result',\n                                'data':data_dict['content']['data'],\n                                'execution_count':data_dict['content']['execution_count']});\n        }\n        else if (data_dict['msg_type'] == 'display_data')\n        {\n            accumulated_data.push( {'output_type':'display_data',\n                                'data':data_dict['content']['data']});\n        }\n        else if (data_dict['msg_type'] == 'error')\n        {\n            accumulated_data.push( {'output_type':'error',\n                                'ename':data_dict['content']['ename'],\n                                'evalue':data_dict['content']['evalue'],\n                                'traceback':data_dict['content']['traceback']});\n        }\n        output_store.textContent = JSON.stringify(accumulated_data);\n\n}\n\n\n/**\n * Renders the output of a prompt cell by parsing its stored markdown content\n * and displaying the formatted HTML with syntax highlighting.\n * Retrieves raw markdown from the output store, converts it to HTML using marked.js,\n * and applies Prism.js syntax highlighting to any code blocks.\n * \n * @param {string} cellId - The unique identifier of the prompt cell to render.\n */\nfunction renderOutputPrompt(cellId,tag='')\n{\n    cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    output_store = cell.querySelector('.output-store'+tag);\n    output_display = cell.querySelector('.output-display'+tag);\n    markdown = marked.parse(output_store.textContent);\n    output_display.innerHTML = ''\n    if (markdown)\n    {\n        output_display.innerHTML = markdown;\n        Prism.highlightAllUnder(output_display);\n    }\n\n    requestAnimationFrame(() =&gt; {\n        output_display.scrollTop = output_display.scrollHeight;\n    });\n\n}\n\n\n/**\n * Converts a Jupyter-style MIME bundle into renderable HTML.\n * Checks for image formats (PNG, JPEG), HTML, and plain text in priority order,\n * returning the appropriate HTML string for display.\n * \n * @param {Object} data - A MIME bundle object with keys like 'image/png', 'text/html', etc.\n * @returns {string|undefined} HTML string for the highest-priority format found, or undefined if none match.\n */\nfunction renderData(data)\n{\n   if (data.hasOwnProperty(\"image/png\")){\n      return `&lt;img src=\"data:image/png;base64,${data['image/png']}\"&gt;`;\n   }\n   else if (data.hasOwnProperty(\"image/jpeg\")){\n      return `&lt;img src=\"data:image/jpeg;base64,${data['image/jpeg']}\"&gt;`;\n   }\n   else if (data.hasOwnProperty(\"text/html\")){\n      return data['text/html'];\n   }\n   else if (data.hasOwnProperty(\"text/plain\")){\n      return `&lt;div class=\"result-output\"&gt;${data['text/plain']}&lt;/div&gt;`;\n   }\n}\n\n\n/**\n * Renders the accumulated execution output for a code cell by parsing the stored JSON\n * and converting it to displayable HTML. Handles multiple Jupyter output types:\n * - stream: Concatenates text chunks into a single div (stdout/stderr)\n * - execute_result/display_data: Delegates to renderData() for MIME bundle rendering\n * - error: Formats exception name, value, and ANSI-colored traceback\n * \n * Uses AnsiUp to convert ANSI escape codes in tracebacks to styled HTML.\n * \n * @param {string} cellId - The unique identifier of the code cell to render output for.\n */\nfunction renderOutput(cellId, tag='')\n{\n    ansi_up = new AnsiUp();\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    const output_store = cell.querySelector('.output-store'+tag);\n    const output_display = cell.querySelector('.output-display'+tag);\n\n    const data = JSON.parse(output_store.textContent)\n\n    let out_html = ''\n\n    for (i = 0; i &lt; data.length; i++)\n        {\n            if (data[i]['output_type'] == 'stream')\n            {\n                const text_list = data[i]['text'];\n                const text_len = text_list.length;\n\n                out_html += '&lt;div class=\"stream-output\"&gt;';\n                for (s = 0; s &lt; text_len; s++  )\n                    {\n                         out_html += text_list[s];\n                    }\n                out_html += `&lt;/div&gt;`;\n            }\n            else if (data[i]['output_type'] == 'execute_result' || data[i]['output_type'] == 'display_data' )\n            {\n                out_html += renderData(data[i]['data']);\n            }\n            else if (data[i]['output_type'] == 'error')\n            {\n                const trace_list = data[i]['traceback'];\n                const trace_len = trace_list.length;\n\n                // out_html += `&lt;div class=\"error-name\"&gt;${data[i].ename}: ${data[i].evalue}&lt;/div&gt;`;\n                out_html += '&lt;pre class=\"traceback\"&gt;';\n                for (s = 0; s &lt; trace_len; s++  )\n                    {\n                         out_html += ansi_up.ansi_to_html(trace_list[s]);\n                         out_html += `\n`;\n                    }\n                out_html += '&lt;/pre&gt;';\n\n            }\n\n        }\n    output_display.innerHTML = out_html; \n\n    requestAnimationFrame(() =&gt; {\n        output_display.scrollTop = output_display.scrollHeight;\n    });\n\n}\n\n\n/**\n * Removes a cell element from the DOM by its unique identifier.\n * \n * @param {string} cellId - The unique identifier of the cell to delete.\n */\n function deleteCell(cellId) {\n    document.querySelector(`[data-cell-id=\"${cellId}\"]`).remove();\n}\n\n\n/**\n * Moves a cell down by swapping its position with its next sibling element.\n * If no next sibling exists, the cell remains in place.\n * \n * @param {string} cellId - The unique identifier of the cell to move down.\n */\n function moveDown(cellId){\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    // Check Sibling\n    const sibling = cell.nextElementSibling;\n    if (sibling){\n        cell.parentNode.insertBefore(sibling,cell);\n    }\n}\n\n\n/**\n * Moves a cell up by swapping its position with its previous sibling element.\n * If no previous sibling exists, the cell remains in place.\n * \n * @param {string} cellId - The unique identifier of the cell to move up.\n */\nfunction moveUp(cellId){\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    \n    // Check Sibling\n    const sibling = cell.previousElementSibling;\n    if (sibling){\n        cell.parentNode.insertBefore(cell,sibling);\n    }\n}\n\n\n/**\n * Gathers all cells above a given cell and formats them for LLM context.\n * Collects each cell's id, type, source content, and outputs until reaching the target cell.\n * \n * @param {string} cellId - The unique identifier of the cell to stop at (exclusive).\n * @returns {Array&lt;Object&gt;} Array of cell objects with cell_id, cell_type, source, and outputs.\n */\nfunction gatherCellsForLLM(cellId){\n    let cell_out_list = [];\n    const cells = document.querySelectorAll('[data-cell-id]');\n    for (let i = 0; i &lt; cells.length; i++){\n\n        const cell = cells[i];\n        const id = cell.getAttribute('data-cell-id');\n        const type = cell.getAttribute('data-cell-type');\n        const input = extractCellInput(id);\n        const output = extractCellOutput(id);\n\n        if (cellId == id)\n        {\n            break;\n        }\n    \n        const cell_dict = {'cell_id':id,\n                    'cell_type':type,\n                    'source':input,\n                    'outputs':output,\n                    };\n        cell_out_list.push(cell_dict);\n    }\n    return cell_out_list;\n}\n\n\n/**\n * Extracts the output content from a cell based on its type.\n * For code cells, parses JSON from the output store.\n * For prompt cells, returns the raw text content.\n * \n * @param {string} cellId - The unique identifier of the cell.\n * @returns {Array|string|null} Parsed output array for code cells, string for prompt cells, null otherwise.\n */\nfunction extractCellOutput(cellId){\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    const cell_type = cell.getAttribute('data-cell-type');\n    const output_store = cell.querySelector('.output-store');\n    \n    if (cell_type == 'code')\n        {\n            try{\n                return JSON.parse(output_store.textContent);\n            }catch{\n                return [];\n            }\n        }\n    else if (cell_type == 'prompt')\n        {\n            return output_store.textContent;\n        }\n    else if (cell_type == 'agent')\n    {\n        return getMonacoContent(cellId);\n    }\n        \n    else{\n        return null;\n    }\n}\n\n\n/**\n * Sets up a MutationObserver to watch a cell's output store for changes\n * and automatically re-renders the output when changes are detected.\n * Handles both code cells (renderOutput) and prompt cells (renderPromptOutput).\n * \n * @param {string} cellId - The unique identifier of the cell to watch.\n */\nfunction watchOutputStore(cellId) {\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    const cell_type = cell.getAttribute('data-cell-type');\n\n    // Throttle render to ~15fps\n    let renderPending = false;\n    function throttledRender(fn) {\n        if (renderPending) return;\n        renderPending = true;\n        setTimeout(() =&gt; {\n            fn();\n            renderPending = false;\n        }, 30);\n    }\n\n    const config = { characterData: true, childList: true, subtree: true };\n\n    // Initial render\n    if (cell_type == 'code') {\n        renderOutput(cellId);\n    } else if (cell_type == 'prompt') {\n        renderOutputPrompt(cellId);\n    } else if (cell_type == 'agent') {\n        renderOutputPrompt(cellId, '-llm');\n        renderOutput(cellId, '-code');\n    }\n\n    // Set up observers\n    if (cell_type == 'code') {\n        const output_store = cell.querySelector('.output-store');\n        new MutationObserver(() =&gt; throttledRender(() =&gt; renderOutput(cellId)))\n            .observe(output_store, config);\n    } else if (cell_type == 'prompt') {\n        const output_store = cell.querySelector('.output-store');\n        new MutationObserver(() =&gt; throttledRender(() =&gt; renderOutputPrompt(cellId)))\n            .observe(output_store, config);\n    } else if (cell_type == 'agent') {\n        const output_store_llm = cell.querySelector('.output-store-llm');\n        const output_store_code = cell.querySelector('.output-store-code');\n        new MutationObserver(() =&gt; throttledRender(() =&gt; renderOutput(cellId, '-code')))\n            .observe(output_store_code, config);\n        new MutationObserver(() =&gt; throttledRender(() =&gt; renderOutputPrompt(cellId, '-llm')))\n            .observe(output_store_llm, config);\n    }\n}\n\nasync function saveNotebook(filename) {\n    const cells = gatherCellsForLLM(null);  // null = gather all cells\n    await fetch(`/save_notebook/${filename}`, {\n        method: 'POST',\n        headers: {'Content-Type': 'application/json'},\n        body: JSON.stringify({cells: cells})\n    });\n    console.log('Notebook saved!');\n}\n\nsetInterval(() =&gt; {\n    const notebookName = document.querySelector('.notebook-name')?.value || 'untitled';\n    saveNotebook(notebookName+'.ipynb');\n}, 5000);\n\n\n\n\n/**\n * Retrieves the code content from a Monaco editor instance within a cell.\n * \n * @param {string} cellId - The unique identifier of the cell containing the Monaco editor.\n * @returns {string} The current text content of the Monaco editor model.\n */\nfunction setMonacoContent(cellId, txt) {\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    const monaco_container = cell.querySelector('.monaco-editor');\n\n    // 1. Get the URI (ensure you grab it from the correct element in your DOM)\n    const uri = monaco_container.dataset.uri || \n                monaco_container.querySelector('[data-uri]')?.dataset.uri;\n\n    const monaco_model = monaco.editor.getModels().find(\n        m =&gt; m.uri.toString() === uri\n    );\n\n    if (monaco_model) {\n        monaco_model.setValue(txt);\n\n        // 2. Find the editor instance attached to this model\n        const editorInstance = monaco.editor.getEditors().find(\n            e =&gt; e.getModel() === monaco_model\n        );\n\n        // 3. Use the REAL method to scroll to the last line\n        if (editorInstance) {\n            editorInstance.revealLine(monaco_model.getLineCount());\n        }\n    }\n}\n\n\ndocument.addEventListener('DOMContentLoaded', () =&gt; {\n    // Adjust all textareas on load + input\n    document.querySelectorAll('textarea[class*=\"content-edit\"]').forEach(textarea =&gt; {\n        textarea.style.height = 'auto';\n        textarea.style.height = Math.min(textarea.scrollHeight, 500) + 'px';\n        \n        textarea.addEventListener('input', () =&gt; {\n            textarea.style.height = 'auto';\n            textarea.style.height = Math.min(textarea.scrollHeight, 500) + 'px';\n        });\n    });\n\n    // Adjust when toggling to edit mode\n    document.querySelectorAll('.toggle-edit').forEach(checkbox =&gt; {  // Changed selector\n        checkbox.addEventListener('change', () =&gt; {\n            if (checkbox.checked) {\n                const cell = checkbox.closest('[data-cell-id]');  // Changed - find parent cell\n                const textarea = cell?.querySelector('textarea.content-edit');  // Changed\n                if (textarea) {\n                    textarea.style.height = 'auto';\n                    textarea.style.height = Math.min(textarea.scrollHeight, 500) + 'px';\n                }\n            }\n        });\n    });\n});\n\nlet currentFocusedCellId = null;\n\ndocument.addEventListener('click', (e) =&gt; {\n    const cell = e.target.closest('[data-cell-id]');  // Changed from [type=\"cell\"]\n    \n    // Remove outline from all cells\n    document.querySelectorAll('[data-cell-id]').forEach(c =&gt; {  // Changed\n        c.style.outline = 'none';\n    });\n    \n    // Add outline to clicked cell\n    if (cell) {\n        cell.style.outline = '2px solid #3b82f6';\n        cell.style.outlineOffset = '-8px';\n        cell.style.borderRadius = '16px';\n        currentFocusedCellId = cell.dataset.cellId;  // Changed from cell.id\n    }\n    document.querySelectorAll('.toggle-edit').forEach(t =&gt; {  // Changed selector\n        const tCell = t.closest('[data-cell-id]');\n        if (tCell && tCell.dataset.cellId !== cell?.dataset.cellId) {\n            t.checked = false;\n        }\n    });\n    const isContentArea = e.target.closest('.markdown-body') || \n                        e.target.closest('textarea[class*=\"content-edit\"]');\n\n    if (isContentArea && cell) {\n        const toggleCheckbox = cell.querySelector('.toggle-edit');  // Changed - find within cell\n        if (toggleCheckbox) {\n            toggleCheckbox.checked = true;\n            toggleCheckbox.dispatchEvent(new Event('change'));\n        }\n    }\n});\n\"\"\"\n\n\nCSS\n\nCSS = \"\"\"\n\n.markdown-body { \n    background-color: bg-gray-900 !important; \n}\n.markdown-body ul { \n    list-style-type: disc !important; \n    padding-left: 2em !important; \n}\n.markdown-body ol { \n    list-style-type: decimal !important; \n    padding-left: 2em !important; \n}\n[data-cell-id].minimized .output-display-llm,\n[data-cell-id].minimized .output-display-code {\n    display: none !important;\n}\n[data-cell-id].minimized .content-edit,\n[data-cell-id].minimized .content-render,\n[data-cell-id].minimized .output-display,\n[data-cell-id].minimized .text-gray-400 {\n    display: none;\n}\n[data-cell-id].minimized .content-edit,\n[data-cell-id].minimized .content-render {\n    display: none !important;\n}\n[data-cell-id].minimized .monaco-editor,\n[data-cell-id].minimized .content-edit,\n[data-cell-id].minimized .content-render,\n[data-cell-id].minimized .output-display {\n    max-height: 0 !important;\n    overflow: hidden;\n}\n[data-cell-id].minimized .bg-gray-800 {\n    opacity: 0.5 !important;\n}\nbody {\n    background-color: #070707 !important;  /* 95% black = 5% brightness */\n}\n.markdown-body { \n    background-color: bg-gray-900 !important;\n    font-size: 0.825rem !important;  /* ‚Üê Smaller base size */\n}\n.markdown-body h1 { font-size: 1.25rem !important; }\n.markdown-body h2 { font-size: 1.1rem !important; }\n.markdown-body h3 { font-size: 1.0rem !important; }\n.markdown-body ul, .markdown-body ol { \n    list-style-type: disc !important; \n    padding-left: 2em !important;\n    font-size: 0.825rem !important;  /* ‚Üê Match body */\n}\n.content-edit {\n    font-size: 0.825rem !important;  /* ‚Üê Textarea size */\n}\n\n.content-render {\n    background-color: #1a1a1a  !important;  /* ‚Üê Medium grey for rendered input */\n}\n.running { color: #ef4444 !important; }\n.complete { color: #22c55e !important; }\n#notebook-container {\n    height: calc(100vh - 64px); \n    overflow-y: auto;\n.toggle-edit:checked ~ .content-edit { display: block; }\n.toggle-edit:checked ~ .content-render { display: none; }\n.toggle-edit:not(:checked) ~ .content-edit { display: none; }\n.toggle-edit:not(:checked) ~ .content-render { display: block;}\nlabel:has(.tool-toggle:not(:checked)) {\n\n    opacity: 0.3;\n\n}\n\"\"\"\n\n\n#  Depricated Agent Code\nAGENT_CODE = \"\"\"\n\n/**\n * Executes a prompt cell by sending its content to the LLM endpoint and streaming the response.\n * Clears previous output, gathers conversation context from cells above, and renders\n * the streamed response into the cell's output area.\n * \n * @param {string} cellId - The unique identifier of the prompt cell to execute.\n */\nfunction executeAgentCell(cellId)\n{\n    // Clear Cell\n    clearOutput(cellId);\n\n\n    const error_text = `\n ** Error In Stream ** \n` ;\n    // Get Output Area to Write To\n    const cell = document.querySelector(`[data-cell-id=\"${cellId}\"]`);\n    const output_store_llm = cell.querySelector('[class=\"output-store-llm\"]');\n    const output_store_code = cell.querySelector('[class=\"output-store-code\"]');\n    const status_div = cell.querySelector('#status');\n    const iteration_div = cell.querySelector('#iteration');\n    const output_display_llm = cell.querySelector('.output-display-llm');\n    const output_display_code = cell.querySelector('.output-display-code');\n\n\n    // Turn Off Edit Mode\n    const toggle_edit = cell.querySelector('.toggle-edit');\n    toggle_edit.checked = false;\n\n    // Prep Data\n\n    const prompt = extractCellInput(cellId);\n    const existingCode = getMonacoContent(cellId);\n    const hasCode = existingCode && existingCode.trim().length &gt; 0;\n\n    const chat_history = gatherCellsForLLM(cellId);\n\n    const notebook_name = document.querySelector('.notebook-name')?.value || 'untitled';\n\n    const chat_data = {\n        'prompt': prompt,\n        'existing_code': hasCode ? existingCode : null,\n        'context': chat_history  ,\n        'notebook': notebook_name \n    };\n    \n    setMonacoContent(cellId,'')\n\n    let tag;\n    let iter = 0;\n    (async () =&gt; {\n    const { fetchEventSource } = await import('https://esm.sh/@microsoft/fetch-event-source@2.0.1');\n    await fetchEventSource(`/agent_tool_build/${cellId}`, {\n        method: 'POST',\n        headers: {'Content-Type': 'application/json'},\n        body: JSON.stringify(chat_data),\n        onclose() {\n        throw new Error('Stream closed');  // Prevents retry\n        },\n        onmessage(ev) {\n\n\n            // Try to recieve packet\n            try{\n\n                const packet = JSON.parse(ev.data)\n                const { type, data } = packet;\n\n                //////////////////////\n                // Set GUI Tags / Labels\n                //////////////////////\n                if (type == 'tag')\n                {\n                    if ( data.includes('review-box'))\n                    {\n                        status_div.textContent = 'Reviewing Unit Test';\n                        tag = 'llm';\n                        output_store_llm.textContent = ''\n                    }\n                    if (data.includes('code-box' ))\n                    {\n                        iter += 1\n                        iteration_div.textContent = 'Iteration: '+iter.toString();\n                        \n                        status_div.classList.remove('complete');\n                        status_div.classList.add('running');\n                        status_div.textContent = 'Writing Code';\n\n                        // When finished successfully\n\n                        tag = 'code';\n                        setMonacoContent(cellId,'')\n\n                    }\n                    if (data.includes('unit-box' ))\n                    {\n                        status_div.textContent = 'Exectuting Unit Test';\n                        tag = 'unit';\n                  \n                    }\n                    if (data.includes( 'DONE')) \n                    {\n                        status_div.classList.remove('running');\n                        status_div.classList.add('complete');\n                        status_div.textContent = 'Code Approved!';\n                        throw new Error('Stream complete');  // Stops retry\n                    }\n                    if (data.includes( 'tool-websearch')) \n                    {\n                        status_div.classList.remove('complete');\n                        status_div.classList.add('running');\n                        status_div.textContent = 'Searching Web';\n\n                    }\n                    if (data.includes( 'tool-readurl')) \n                    {\n                        status_div.textContent = 'Checking Website';\n\n                    }\n                }\n                ///////////////////////\n                //  Accumulate Stream\n                ///////////////////////\n                else if( type == 'text')\n                {\n                    // accumulate stream\n                    if  (tag == 'llm')\n                    {\n                        output_store_llm.textContent += data ;\n                        output_display_llm.scrollTop = output_display_llm.scrollHeight;\n                    }\n                    else if  (tag == 'code')\n                    {\n                        const code = getMonacoContent(cellId);\n                        setMonacoContent(cellId,code+data);\n                    }\n\n                }\n                else if(type == 'output')\n                {\n                        // Unit doesnt stream atm so we replace\n                        output_store_code.textContent = JSON.stringify(data);\n                        requestAnimationFrame(() =&gt; {\n                            output_display_code.scrollTop = output_display_code.scrollHeight;\n                        });\n                }\n\n            }\n            // Print error \n            catch(error){\n                if (error.message === 'Stream complete') throw error; \n\n                if  (tag == 'llm')\n                {\n                    output_store_llm.textContent += error_text ;\n                }\n                else if  (tag == 'code')\n                {\n                    const code = getMonacoContent(cellId);\n                    setMonacoContent(cellId,code+error_text);\n                }\n                else if  (tag == 'unit')\n                {\n                    // Unit doesnt stream atm so we replace\n                    output_store_code.textContent = JSON.stringify([{\n                        output_type: 'error',\n                        ename: 'StreamError',\n                        evalue: 'Error in stream',\n                        traceback: [error_text]\n                    }]);\n                }\n            }\n        },\n        onerror(error) {\n\n            throw error;  // Throwing from onerror stops retry\n\n        },\n    });\n    })();\n}\n\"\"\"\n\n\n\nExport Javascript and CSS to files\n\nfrom pathlib import Path\nimport importlib.resources\n\n# Get the static directory path\nstatic_dir = Path(importlib.resources.files('llm_sandbox_ui')) / 'static'\n\n# Write both files\n(static_dir / 'cells.js').write_text(JAVASCRIPT)\n(static_dir / 'styles.css').write_text(CSS)\n\nprint(f\"Written to {static_dir}\")\n\nWritten to /app/data/unreal/unreal-llm-sandbox/unreal_llm_sandbox/static",
    "crumbs": [
      "Java Script"
    ]
  },
  {
    "objectID": "cells.html",
    "href": "cells.html",
    "title": "Cells",
    "section": "",
    "text": "interrupt_button\n\ndef interrupt_button(\n    cell_id\n):\n\nCreate an interrupt button that aborts the active stream for a cell.\nArgs: cell_id: Unique cell identifier.\nReturns: Button component that POSTs to /interrupt/{cell_id}.\n\n\n\nBaseCell\n\ndef BaseCell(\n    source:str='', outputs:str='', cell_id:NoneType=None\n):\n\nBase class for all notebook cell types.\nAttributes: cell_type (str): Type identifier (‚Äòmarkdown‚Äô, ‚Äòcode‚Äô, ‚Äòllm‚Äô). source (str): Cell content/code. outputs (list): Cell execution outputs (empty for markdown). cell_id (str): Unique cell identifier.\n\n\n\nPromptCell\n\ndef PromptCell(\n    source:str='', outputs:str='', cell_id:NoneType=None\n):\n\nCell for LLM prompts with streaming markdown responses.\nStores user prompt in source and LLM response in outputs. Serializes to ipynb as markdown with PROMPT_SPLIT separator.\n\n\n\nMarkdownCell\n\ndef MarkdownCell(\n    source:str='', outputs:str='', cell_id:NoneType=None\n):\n\nStatic markdown documentation cell.\nDisplays rendered markdown with toggle to edit source. No execution or outputs - purely for notes and documentation.\n\n\n\nCodeCell\n\ndef CodeCell(\n    source:str='', outputs:str='', cell_id:NoneType=None\n):\n\nExecutable Python code cell with Monaco editor.\nExecutes code via kernel and displays Jupyter-style outputs (streams, execute_result, display_data, errors).\n\nclass AgentCell(BaseCell):\n    \"\"\"Autonomous code generation cell with iterative refinement.\n    \n    Combines a prompt input, Monaco code editor, and dual output areas\n    (unit test results + LLM review). Runs generate‚Üítest‚Üíimprove loops\n    until code passes review.\n    \n    Attributes:\n        source_prompt: User's code generation request.\n        source_code: Generated/edited Python code.\n        outputs_llm: Agent review markdown.\n        outputs_code: Unit test execution outputs.\n    \"\"\"\n    cell_type = 'agent'\n\n\n    def __init__(self, source_prompt=\"\", source_code=\"\", outputs=\"\", outputs_llm=\"\",outputs_code=\"\", cell_id=None):\n        super().__init__(source=\"\", outputs=outputs, cell_id=cell_id)\n        self.source_prompt = source_prompt\n        self.source_code = source_code\n        self.outputs_llm = outputs_llm\n        self.outputs_code = outputs_code\n\n    @classmethod\n    def from_ipynb(cls, cell_dict):\n        \"\"\" Load From Ipynb Dict\"\"\"\n\n        source_txt = ''.join(cell_dict['source'])\n        code = \"\"  # ‚Üê Add default\n        if AGENT_CODE_SPLIT in source_txt:\n            prompt, code = source_txt.split(AGENT_CODE_SPLIT)\n            re_outputs = re.search(r'```python\\n(.*?)\\n```', code, re.DOTALL)\n            if re_outputs:\n                code = re_outputs.group(1)\n        else:\n            prompt = source_txt\n\n        return cls(source_prompt=prompt, \n                source_code=code,\n                cell_id=cell_dict['id'])\n\n    def to_ipynb(self):\n        \"\"\" Build Ipynb Dict\"\"\"\n\n        out_dict = {\n            'id':self.cell_id,\n            'cell_type': 'markdown',\n            'metadata': {'id': self.cell_id, 'agent_cell': True}\n        }\n        \n        # Combine prompt + code with separator\n        if self.source_code:\n            source_text = self.source_prompt + AGENT_CODE_SPLIT + '```python\\n' + self.source_code + '\\n```'\n        else:\n            source_text = self.source_prompt\n        \n        out_dict['source'] = source_text.splitlines(keepends=True)\n        \n        return out_dict\n\n    def build_left_buttons(self):\n        \"\"\"Build cell-specific left button group (play, stop, etc).\"\"\"\n        \n        return Div(\n                Div(\n                    Button(play_ic,\n                            onClick=f\"executeAgentCell('{self.cell_id}')\",\n                            cls=cell_button_format),\n                    interrupt_button(self.cell_id),\n                    Button(clean_ic,\n                            onClick=f\"clearOutput('{self.cell_id}')\",\n                            cls=cell_button_format),\n                    Label(edit_ic,\n                            cls=cell_button_format + ' toggle-label'),\n                ),\n                cls='flex justify-start'\n                )\n\n    def build_source_area(self):\n        \"\"\"Build editable source code/markdown area.\"\"\"\n\n        markdown_source = self.build_markdown_source_area(self.source_prompt,round_b=False)\n\n        monaco_editor_script = self.build_monaco_editor(self.cell_id,self.source_code,100,300)\n       \n\n        editor_div = Div(id=f'monaco-{self.cell_id}', \n                        style='height: 20px; width: 100%; overflow: hidden',\n                        cls='monaco-editor')\n\n        agent_in = Div(\"Prompt\", cls=label_css),\n\n        code_in = Div(\n            Div(\"Agent Code\", cls=\"flex-shrink-0\"),\n            Div(\"Idle\", id=f\"status\", \n                cls=\"flex-grow px-3 py-0.5 bg-gray-900 rounded text-center text-xs\"),\n            Div(\"Iteration: NA\", id=f\"iteration\",\n                cls=\"flex-shrink-0 px-2 py-0.5 bg-gray-900 rounded text-xs\"),\n            cls=\"flex items-center gap-2 text-xs text-gray-400 px-2 py-1 bg-gray-800\"\n        )\n\n\n        return [agent_in, *markdown_source,code_in,editor_div, monaco_editor_script]\n\n    def build_output_area(self):\n        \"\"\"Build output display area (if applicable).\"\"\"\n\n        ### Code Out\n        outputs_json = json.dumps(self.outputs_code) if self.outputs_code else '[]'\n        output_area_code = self.build_code_output(tag='-code',min_height=100, max_height=300, outputs_json=outputs_json, round_b=False)\n\n        ### LLM Out\n        outputs_json = self.outputs_llm if self.outputs_llm else ''\n        output_area_llm = self.build_llm_output( tag='-llm',min_height=100, max_height=300, outputs_json=outputs_json)\n\n\n        agent_out = Div(\"Agent Output\", cls=label_css),\n        code_out = Div(\"Unit Test Output\", cls=label_css),\n\n        return [code_out,*output_area_code,agent_out,*output_area_llm]\n\n    def render(self):\n        \"\"\"Render cell as FastHTML component tree.\"\"\"\n\n        toggle_input = Input(type='checkbox', cls=\"hidden toggle-edit\")\n\n        menu_bar = self.build_top_menu()\n        source_area = self.build_source_area()\n        output_area = self.build_output_area()\n        \n        watch_script = Script(f\"\"\"\n            setTimeout(() =&gt; {{\n                watchOutputStore('{self.cell_id}');\n            }}, 50);\n        \"\"\")\n\n        return Div(\n            watch_script,\n            toggle_input,\n            menu_bar,\n            *source_area,\n            *output_area,\n            self._make_markdown_init_script(),\n            cls='w-full shadow-xl p-2',\n            data_cell_type=self.cell_type,\n            data_cell_id=self.cell_id\n        )",
    "crumbs": [
      "Cells"
    ]
  }
]